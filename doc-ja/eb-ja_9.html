<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on December, 28  2003 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>EB Library: Text Data</TITLE>

<META NAME="description" CONTENT="EB Library: Text Data">
<META NAME="keywords" CONTENT="EB Library: Text Data">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="EN" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC44"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_8.html#SEC43"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC45"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_8.html#SEC35"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 9. テキストデータ </H1>
<!--docid::SEC44::-->
<P>

テキストデータの取得は、検索と並ぶ重要な機能です。
</P><P>

ここで言う <EM>テキストデータ (text data)</EM> は、<EM>本文 (text body)</EM>
という意味ではありません。
CD-ROM 書籍には確かに本文も存在しますが、本文と同じデータ形式を用いて
書かれたデータが数種類あります。
本書では、これらのデータをまとめてテキストデータと呼んでいます。
EB ライブラリが扱えるテキストデータの種類には、次のものがあります。
</P><P>

<UL>
<LI>見出し
<LI>本文
<LI>メニュー
<LI>著作権表示
<LI>複合検索の入力語の候補一覧
</UL>
<P>

本章では、これらのテキストデータの取得と加工方法について説明します。
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC45">9.1 テキストデータのシークと読み込み</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC46">9.2 テキストデータの内部形式</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC47">9.3 フック</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC48">9.4 フックと文字コードの関係</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC49">9.5 著作権表示</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC50">9.6 メニュー</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC51">9.7 複合検索の候補一覧</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC52">9.8 区切りコードの問題</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC53">9.9 サンプルプログラム</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC54">9.10 データ型の詳細</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC55">9.11 フック関数の詳細</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC56">9.12 フックコードの一覧</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC57">9.13 フックセット操作関数の詳細</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC58">9.14 組み込みフック関数の詳細</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_9.html#SEC59">9.15 テキストデータ操作関数の詳細</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Seek and Read Text Data"></A>
<HR SIZE="6">
<A NAME="SEC45"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC46"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.1 テキストデータのシークと読み込み </H2>
<!--docid::SEC45::-->
<P>

UNIX でプログラムを組んだ経験のある方には、ファイルからデータを読み込む
際に用いる <CODE>lseek()</CODE>, <CODE>read()</CODE> というシステムコールをご存じの
方も多いでしょう。
</P><P>

EB ライブラリでも、テキストデータの取得には、<EM>シーク (seek)</EM> と
<EM>読み込み (read)</EM> という 2 つの操作で行います。
ただし、EB ライブラリではファイルポインタやディスクリプタはなく、
<CODE>EB_Book</CODE> オブジェクトを通じてシークや読み込みの操作を行います。
</P><P>

また、シーク時に指定する位置も <CODE>off_t</CODE> 型ではなく、
<CODE>EB_Position</CODE> 型 (「<A HREF="eb-ja_8.html#SEC42">[検索] データ型の詳細</A>」節を参照)
のオブジェクトを用います。
たとえば、本文の先頭位置は、<CODE>eb_text()</CODE> という関数を使って次のように
取得できますが、このときも位置データは <CODE>EB_Position</CODE> 型オブジェクト
に書き込まれます。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>EB_Position position;

/* 関数の処理が成功すると、<CODE>position</CODE> に本文の開始位置が
 * 書き込まれます。 */
if (eb_text(&#38;book, &#38;position) != EB_SUCCESS) {
    fprintf(stderr, "an error occurs.\n");
    return;
}
</pre></td></tr></table></P><P>

参考までに、<CODE>EB_Position</CODE> 型の内部構造は、次のようになっています。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>typedef struct EB_Position_Struct EB_Position;

struct EB_Position_Struct {
    int page;     /* ページ番号 */
    int offset;   /* ページ内のオフセット */
};
</pre></td></tr></table></P><P>

ところで、検索時に一致したエントリの見出しや本文を読み込む際にも、
位置情報の指定には <CODE>EB_Position</CODE> 型が使われます。
一致したエントリの情報は、関数 <CODE>eb_hit_list()</CODE> によって
<CODE>EB_Hit</CODE> という型のオブジェクトに書き込まれますが、<CODE>EB_Hit</CODE>
型は次のように定義されています。
(詳しくは 「<A HREF="eb-ja_8.html#SEC42">[検索] データ型の詳細</A>」節を参照。)
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>typedef struct {
    EB_Position heading;   /* 見出しの位置 */
    EB_Position text;      /* 本文の位置   */
} EB_Hit;
</pre></td></tr></table></P><P>

つまり、このときの見出しと本文の位置も、<CODE>EB_Position</CODE> 型で表現
されているのです。
</P><P>

では、実際のプログラムを例にして、シークと読み込みを行ってみます。
まずは、シークからです。
これには関数 <CODE>eb_seek_text()</CODE> を用います。
ここでもやはり、位置は <CODE>EB_Position</CODE> 型で渡します。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>if (eb_seek_text(&#38;book, &#38;position) != EB_SUCCESS) {
    fprintf(stderr, "an error occurs.\n");
    return;
}
</pre></td></tr></table></P><P>

データの種類 (見出し、本文 ...) によらず、テキストデータのシークは
すべて <CODE>eb_seek_text()</CODE> で行います。
</P><P>

ただし、<CODE>EB_Book</CODE> オブジェクトは、テキストデータの種類別に読み込み
位置を覚えているわけではなく、全種類のテキストデータで共有する位置情報を
一つ覚えているだけです。
たとえば、本文を読み込んだ後で、別の位置にシークして見出しを読み込むと、
<CODE>EB_Book</CODE> は本文の読み込み位置のことは忘れてしまいます。
</P><P>

さて、シークが終わったら、データを読み込みます。
読み込もうとするテキストデータの種類によって、使用する関数が異なります。
見出しだけは <CODE>eb_read_heading()</CODE> を使いますが、それ以外では
<CODE>eb_read_text()</CODE> を使います。
</P><P>

以下は、<CODE>eb_read_text()</CODE> の使用例です。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#define MAX_LENGTH 1000
char buffer[MAX_LENGTH + 1];
ssize_t text_length;

if (eb_read_text(&#38;book, NULL, NULL, NULL, MAX_LENGTH,
    text, &#38;text_length) != EB_SUCCESS) {
    fprintf(stderr, "an error occurs.\n");
    return;
}
</pre></td></tr></table></P><P>

成功すると、<CODE>text</CODE> にはテキストデータが、<CODE>text_length</CODE> には
実際に読み込んだバイト数が書き込まれます。
テキストは最大で <CODE>MAX_LENGTH</CODE> バイト書き込まれます。
テキストデータはさらにナル文字で終端されますので、<CODE>buffer</CODE> には
もう 1 バイト分の領域が必要になります。
</P><P>

<CODE>eb_read_heading()</CODE> の呼び出し方も、<CODE>eb_read_text()</CODE> と
まったく変わりません。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>if (eb_read_heading(&#38;book, NULL, NULL, NULL, MAX_LENGTH,
    text, &#38;text_length) != EB_SUCCESS) {
    fprintf(stderr, "an error occurs.\n");
    return;
}
</pre></td></tr></table></P><P>

<CODE>eb_read_text()</CODE> や <CODE>eb_read_heading()</CODE> で読み込んだ
テキストデータは平文のテキストになっていて、ナル文字で終端されています。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>printf("%s\n", text);   /* 出力してみる */
</pre></td></tr></table></P><P>

読み込みたいテキストデータが長すぎて、<CODE>eb_read_text()</CODE> あるいは
<CODE>eb_read_heading()</CODE> を一回呼び出しただけでは全部読み込めなかった
場合は、再度呼び出すことで続きのデータを読み込むことができます。
</P><P>

<A NAME="Text Data Format"></A>
<HR SIZE="6">
<A NAME="SEC46"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC45"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC47"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.2 テキストデータの内部形式 </H2>
<!--docid::SEC46::-->
<P>

前節の例では、読み込んだテキストデータは、平文テキストになっていました。
けれども、CD-ROM 書籍内に平文テキストのデータが、そのまま収録されている
わけではありません。
</P><P>

実際のテキストデータの例を、以下に示します。
左側のブロックは 16 進数でダンプした様子で、右側はそれを基に JIS X 0208
(日本語のかな漢字) の文字を表している部分を <SAMP>`[　]'</SAMP> という形に
直したものです。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>     (16進数によるダンプ)            (可能な部分をかな漢字に変換)
1f0900011f41010026321f611f042121   1f0900011f410100[Σ]1f611f04[　]
212721211f053e704a734a541f0a1f04   [：][　]1f05[情][報][編]1f0a1f04
214e1f0525372530255e1f04214f2121   [［]1f05[シ][グ][マ]1f04[］][　]
214a237323692367236d236121212370   [（][ｓ][ｉ][ｇ][ｍ][ａ][　][ｐ]
2372236f236a236523632374214b1f05   [ｒ][ｏ][ｊ][ｅ][ｃ][ｔ][）]1f05
</pre></td></tr></table></P><P>

右側のブロックを見ると、おおよそ平文に近い形でテキストデータが収められて
いることが分かりますが、ところどころに「文字」ではないデータも含まれて
います。
</P><P>

文字ではない部分は、すべて「エスケープシーケンス」と呼ばれるものです。
エスケープシーケンスとは、テキストデータを出力する際に、改行の禁止や
強調修飾といった制御情報を伝えるための仕組みです。
16 進数の <SAMP>`1f'</SAMP> が、エスケープシーケンスの開始を意味します。
</P><P>

参考までに、上のテキストデータで使われているエスケープシーケンスを
すべて列挙すると、次のようになります。
</P><P>

<DL COMPACT>
<DT><SAMP>`1f09 0001'</SAMP>
<DD>字下げ (インデント) の量を指定。
(引数が 0001 なので、字下げ量は 1。)
<DT><SAMP>`1f41 0100'</SAMP>
<DD>検索キーの開始。
(引数 0100 の意味については、JIS X 4081 に記述がないため不明。)
<DT><SAMP>`1f61'</SAMP>
<DD>検索キーの終了。
<DT><SAMP>`1f04'</SAMP>
<DD>半角表示の開始。
<DT><SAMP>`1f05'</SAMP>
<DD>半角表示の終了。
<DT><SAMP>`1f0a'</SAMP>
<DD>改行
</DL>
<P>

前節のプログラムで、読み込んだデータが平文テキストになっていたのは、
実は EB ライブラリが加工処理をしたからです。
つまり、「改行」のように平文テキストでも表現可能なエスケープシーケンス
については処理し、「検索キーの開始」のように表現できないものについては
無視するようにして、平文テキストになるように加工していたのです。
</P><P>

しかし、平文テキストは表現力が乏しいので、元のデータには含まれている
エスケープシーケンスの多くを無視することになってしまいます。
HTML のように、もっと表現力のある形式で出力するなら、無視せずに済む
シーケンスを増やせそうです。
では、HTML 形式でテキストデータを取得する関数が EB ライブラリに用意されて
いるかというと、残念ながらありません。
</P><P>

その代わりに、かなり手間はかかりますが、自由にテキストデータを加工できる
ための仕組みが用意されています。
それが、次の節で説明する <EM>フック (hook)</EM> です。
フックを使うことで、テキストデータを柔軟に加工することができます。
</P><P>

<A NAME="Hook"></A>
<HR SIZE="6">
<A NAME="SEC47"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC46"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC48"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.3 フック </H2>
<!--docid::SEC47::-->
<P>

特に何も指定しなければ、<CODE>eb_read_text()</CODE>, <CODE>eb_read_heading()</CODE>
が返すテキストデータの加工は、あらかじめ決められた通りの方法で行われます。
たとえば、「改行」のエスケープシーケンスに対しては、<SAMP>`\n'</SAMP> を
書き込むようになっています。
</P><P>

<EM>フック (hook)</EM> を使うと、こうした加工方法を変えることができます。
フックは、あらかじめ決められたフック設定位置に対して、フック関数を登録
することで有効になります。
フック関数が登録されていると、<CODE>eb_read_text()</CODE> や
<CODE>eb_read_heading()</CODE> は、あらかじめ決まったやり方でデータを書き込む
代わりに、フック関数を呼び出します。
呼び出されたフック関数がデータの書き込み処理を行うことで、
<CODE>eb_read_text()</CODE> や <CODE>eb_read_heading()</CODE> から返るテキストデータ
が変化するというわけです。
</P><P>

EB ライブラリには、多数のフック設定位置が用意されています。
各エスケープシーケンスには、それぞれ専用にフックが用意されており、
それ以外にも文字のためのフックが存在します。
(どのようなフック設定位置があるか、詳しくは 
「<A HREF="eb-ja_9.html#SEC56">フックコードの一覧</A>」節を参照。)
</P><P>

それぞれのフック設定位置は、<EM>フックコード (hook code)</EM> と呼ばれる
コード値で識別されます。
たとえば、前述の「改行」のエスケープシーケンスに対応するフックコード
は <CODE>EB_HOOK_NEWLINE</CODE> になります。
</P><P>

アプリケーションプログラムがフックを扱うには、フックの集合である
<EM>フックセット (hook set)</EM> を用意します。
これは、EB ライブラリで利用可能なすべてのフック設定位置に対して、どの
フック関数を使うのかを記録するためのオブジェクトです。
</P><P>

では、実際にどうやってフックセットを扱うのか、説明していきましょう。
フックセットは <CODE>EB_Hookset</CODE> 型のオブジェクトで表しますので、まず
<CODE>EB_Hookset</CODE> オブジェクトを用意します。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>EB_Hookset hookset;
</pre></td></tr></table></P><P>

<CODE>EB_Hookset</CODE> オブジェクトは、<CODE>EB_Book</CODE> オブジェクトと同様に、
使用前に必ず初期化する必要があります。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>eb_initialize_hookset(&#38;hookset);
</pre></td></tr></table></P><P>

実際のフック関数は、次のようなものになります。
この例では、フック関数の中で <CODE>eb_write_text_string()</CODE> という関数を
呼び出して、<SAMP>`&#60;br&#62;'</SAMP> という文字列をテキストデータとして書き込んで
います。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>EB_Error_Code
hook_newline(EB_Book *book, EB_Appendix *appendix, void *container,
    EB_Hook_Code code, int argc, const unsigned int *argv) {
    eb_write_text_string(book, "&#60;br&#62;");
    return 0;
}
</pre></td></tr></table></P><P>

関数 <CODE>eb_set_hook()</CODE> を用いることで、このフック関数をフックセット
に登録することができます。
ただし、まず <CODE>EB_Hook</CODE> という型のオブジェクトにいったんフックコード
とフック関数を設定し、それを <CODE>eb_set_hook()</CODE> を渡してやる必要が
あります。
ここでは、「改行」を表すエスケープシーケンスに対して、上記のフック関数
を登録してみます。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>EB_Hook hook;

hook.code = EB_HOOK_NEWLINE;   # フックコードをセット
hook.function = hook_newline;  # フック関数をセット
eb_set_hook(&#38;hookset, &#38;hook);
</pre></td></tr></table></P><P>

なお、同じフック設定位置 (フックコード) に複数回フック関数を登録しても、
有効になるのは最後に登録したものだけですので、注意して下さい。
フック関数として <CODE>NULL</CODE> を指定すると、登録されているフックが解除
されます。
</P><P>

関数 <CODE>eb_set_hooks()</CODE> (最後に <CODE>s</CODE> が付く) を使えば、複数の
フック関数を一度に登録できます。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>static const EB_Hook hooks[] = {
    {EB_HOOK_NEWLINE,        hook_newline},
    {EB_HOOK_SET_INDENT,     hook_set_indent},
    {EB_HOOK_WIDE_JISX0208,  hook_set_jisx0208},
    {EB_HOOK_NULL,           NULL}
};

eb_set_hooks(&#38;hookset, &#38;hooks);
</pre></td></tr></table></P><P>

配列の末尾を明示するために、<CODE>EB_HOOK_NULL</CODE> という特殊なフックコード
を置きます。
この点も注意して下さい。
</P><P>

こうしてフック関数を登録したフックセットを、<CODE>eb_raed_text()</CODE>,
<CODE>eb_raed_heading()</CODE> への引数として渡します。
前節までの例では、<CODE>NULL</CODE> を渡していましたが、代わりに
<CODE>&#38;hookset</CODE> を渡してみます。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>if (eb_read_text(&#38;book, NULL, &#38;hookset, NULL, MAX_LENGTH,
    text, &#38;text_length) != EB_SUCCESS) {
    fprintf(stderr, "an error occurs.\n");
    return;
}
</pre></td></tr></table></P><P>

これによって、テキストデータ中に改行を表すエスケープシーケンスがあると、
<SAMP>`\n'</SAMP> の代わりに <SAMP>`&#60;br&#62;'</SAMP> という文字列が書き込まれるようになります。
</P><P>

<CODE>EB_Hookset</CODE> オブジェクトを使い終わったら、<CODE>eb_finalize_hookset()</CODE>
を呼んで後始末をします。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>eb_finalize_hookset(&#38;hookset);
</pre></td></tr></table></P><P>

<A NAME="Hook and Character Code"></A>
<HR SIZE="6">
<A NAME="SEC48"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC47"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC49"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.4 フックと文字コードの関係 </H2>
<!--docid::SEC48::-->
<P>

前節では、エスケープシーケンスに対するフックを例にとりましたが、この他
にも、EB ライブラリには文字に対するフックが用意されています。
</P><P>

<DL COMPACT>
<DT><CODE>EB_HOOK_ISO8859_1</CODE>
<DD>ISO 8859-1 (ラテン文字 1) 文字へのフック。ただし制御文字を除きます。
引数として、ISO 8859-1 の文字番号がフック関数に渡されます。
<P>

<DT><CODE>EB_HOOK_NARROW_JISX0208</CODE>
<DD>半角の JIS X 0208 (日本語のかな漢字) 文字へのフック。
引数として、日本語 EUC で表現した場合の文字番号が、フック関数に渡されます。
<P>

<DT><CODE>EB_HOOK_WIDE_JISX0208</CODE>
<DD>全角の JIS X 0208 (日本語のかな漢字) 文字へのフック。
引数として、日本語 EUC で表現した場合の文字番号が、フック関数に渡されます。
<P>

<DT><CODE>EB_HOOK_GB2312</CODE>
<DD>GB 2312 (中国語の簡体字) 文字へのフック。
引数として、中国語 EUC で表現した場合の文字番号が、フック関数に渡されます。
<P>

<DT><CODE>EB_HOOK_NARROW_FONT</CODE>
<DD>半角の外字へのフック。
引数として、外字の文字番号が、フック関数に渡されます。
<P>

<DT><CODE>EB_HOOK_WIDE_FONT</CODE>
<DD>半角の外字へのフック。
引数として、外字の文字番号が、フック関数に渡されます。
</DL>
<P>

いずれも、その文字がテキストデータ中に現れる度に、フック関数が呼び出され
ます。
</P><P>

上の記述を見ても分かるように、フック関数に渡される文字番号は、書籍の文字
コードに応じて、ISO 8859-1, 日本語 EUC、中国語 EUC のいずれかの文字コード
で表現されたものになります。
</P><P>

フック関数を登録しなければ、その文字番号がテキストデータとしてそのまま
書き込まれます。
</P><P>

もし、アプリケーションプログラムが、EB ライブラリの内部コードとは異なる
文字コードを使用したい場合は、これらのフックのフック関数を登録して、
コード変換処理をするのも手です。
ただし、一文字毎にフック関数が呼び出されるので、相応の負荷がかかります。
</P><P>

また、EBXA-C を扱うには、特別な処理が必要です。
EBXA-C では、文字コードとして GB 2312 と JIS X 0208 が使われますが
(「<A HREF="eb-ja_2.html#SEC6">文字コード</A>」節を参照)、EB ライブラリによる標準の処理
では、どちらも 0xa1a1 〜 0xfefe にマッピングされて衝突するため、最低
でもどちらか一方をフックして文字の表現方法を変えないと、正しく出力
できません。
</P><P>

<A NAME="Copyright Notice"></A>
<HR SIZE="6">
<A NAME="SEC49"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC48"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC50"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.5 著作権表示 </H2>
<!--docid::SEC49::-->
<P>

先に記したように、テキストデータには何種類かあり、その中に
<EM>著作権表示 (copyright notice)</EM> というものがあります。
名前の通り、著作権表示に関するテキストデータを収めたものです。
</P><P>

一般に、著作権表示は本文とはまったく独立したデータとして用意されます。
したがって、本文を先頭から末尾まで読んでみても、著作権表示はどこにも
見つかりません。
</P><P>

選択中の副本について、著作権表示の開始位置を知るには <CODE>eb_copyright()</CODE>
を使います。
この関数は、副本が著作権表示を持っていなければ <CODE>EB_ERR_NO_SUCH_SEARCH</CODE>
を返しますので、著作権表示の有無も同時に分かります。
(開始位置は取得せずに、有無だけを調べたいときは、<CODE>eb_have_copyright()</CODE>
という関数が使えます。)
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>EB_Position position;
EB_Error_Code err;

err = eb_copyright(&#38;book, &#38;position);
if (err == EB_ERR_NO_SUCH_SEARCH) {
    /* 著作権表示はない */
} else if (err != EB_SUCCESS) {
    /* それ以外のエラー */
   return;
}
</pre></td></tr></table></P><P>

後は、得られた位置 (<CODE>position</CODE>) にシークして、<CODE>eb_read_text()</CODE>
でテキストデータを読み込みます。
</P><P>

<A NAME="Menu"></A>
<HR SIZE="6">
<A NAME="SEC50"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC49"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC51"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.6 メニュー </H2>
<!--docid::SEC50::-->
<P>

本文とは独立したテキストデータとしては、著作権表示の他に
<EM>メニュー (menu)</EM> というものがあります。
メニューは、主に本文の補助となるデータを収録しています。
代表的なものでは、「前書き (序)」「凡例」といったものが挙げられます。
</P><P>

メニューでは「別項目参照」というエスケープシーケンスを多用して、階層的
な構造になっているのが一般的です。
このエスケープシーケンスには、参照先のテキストの位置が記録されています。
</P><P>

たとえば、ある CD-ROM 書籍のメニューが次のようになっていたとします。
この例では、メニューには 3 つの項目があります。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> * 序文
 * 表記について
 * 奥付
</pre></td></tr></table></P><P>

メニューのそれぞれの項目には、参照先があります。
テキストデータの内部表現では、「序文」「表記について」「奥付」の
それぞれの文字列の前後に別項目参照開始および終了エスケープシーケンスが
付いた形になっています。
視覚的に分かるように記すと、次のような形になっています。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre> * &#60;別項目参照開始シーケンス&#62; "序文" &#60;別項目参照終了シーケンス&#62;
 * &#60;別項目参照開始シーケンス&#62; "表記" &#60;別項目参照終了シーケンス&#62;
 * &#60;別項目参照開始シーケンス&#62; "奥付" &#60;別項目参照終了シーケンス&#62;
</pre></td></tr></table></P><P>

HTML の書き方を知っているなら、<SAMP>`a'</SAMP> タグと言えば分かるのではないか
と思います。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>&#60;a href="./index-ja.html"&#62;EB ライブラリのホームページ&#60;/a&#62;
</pre></td></tr></table></P><P>

ただし、参照先の位置情報は終了シーケンス側に記載されますので、この点は
HTML とは逆になります。
蛇足ですが、別位置参照はメニューだけでなく、本文でも一般的に使用されます。
</P><P>

別項目参照開始および終了シーケンスに対して、それぞれフック
<CODE>EB_HOOK_BEGIN_REFERENCE</CODE> と <CODE>EB_HOOK_END_REFERENCE</CODE> が用意
されています。
参照先の位置情報は、終了シーケンスへのフック関数に対して、引数として
渡されます。
たとえば、<CODE>EB_HOOK_END_REFERENCE</CODE> へのフック関数の冒頭では、次の
ようにすると良いかも知れません。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>EB_Error_Code
hook_end_ref(EB_Book *book, EB_Appendix *appendix, void *container,
    EB_Hook_Code code, int argc, const unsigned int *argv)
{
    EB_Position position;

    position.page = argv[1];    # 参照先のページ番号
    position.offset = argv[2];  # 参照先のオフセット
</pre></td></tr></table></P><P>

参照先は、メニューの第 2 層となります。
この書籍の「奥付」の参照先を辿ったら、次のような表記になっていました。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>○○堂出版社 新国語辞典 第 2 版 (EPWING 版)
第 1 版 発行 1988年 2月
第 2 版 発行 1999年 11月
第 2 版 (EPWING 版) 発行 2000年 2月
</pre></td></tr></table></P><P>

同様に「序文」「表記に付いて」の参照先についても、こうした文章データ
が用意されていました。
図示すると、メニューの階層は次のようになります。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>　　　　　　　　　　　　┌─────┐
第１層　　　　　　　　　│メニュー　│
　　　　　　　　　　　　└──┰──┘
　　　　　　　　　　　　　　　┃
　　　　　　　┏━━━━━━━╋━━━━━━━┓
　　　　　　　┃　　　　　　　┃　　　　　　　┃
　　　　┌──┸──┐　┌──┸──┐　┌──┸──┐
第２層　│メニュー　│　│メニュー　│　│メニュー　│
　　　　└─────┘　└─────┘　└─────┘
</pre></td></tr></table></P><P>

この辞書の例では、メニューはここで終わりになっていますが、書籍によっては
さらに第 3 層、第 4 層と続く場合もあります。
また、メニュー全体が均一の階層数になっているとは限りません。
メニューの参照先が本文や著作権表示になっていることもあります。
</P><P>

選択中の副本について、(第 1 層の) メニューの開始位置 を知るには
<CODE>eb_menu()</CODE> を使います。
この関数は、副本がメニューを持っていなければ <CODE>EB_ERR_NO_SUCH_SEARCH</CODE>
を返しますので、メニューの有無も同時に分かります。
(開始位置は取得せずに、有無だけを調べたいときは、<CODE>eb_have_menu()</CODE>
という関数が使えます。)
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>EB_Position position;
EB_Error_Code err;

err = eb_menu(&#38;book, &#38;position);
if (err == EB_ERR_NO_SUCH_SEARCH) {
    /* メニューはない */
} else if (err != EB_SUCCESS) {
    /* それ以外のエラー */
   return;
}
</pre></td></tr></table></P><P>

後は、得られた位置 (<CODE>position</CODE>) にシークして、<CODE>eb_read_text()</CODE>
でテキストデータを読み込みます。
</P><P>

<A NAME="Multi Candidates"></A>
<HR SIZE="6">
<A NAME="SEC51"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC50"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC52"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.7 複合検索の候補一覧 </H2>
<!--docid::SEC51::-->
<P>

「複合検索」(「<A HREF="eb-ja_8.html#SEC38">複合検索</A>」節を参照) のところで述べたように、
複合検索では、入力語に <EM>候補一覧 (candidates)</EM> が用意されていること
があります。
これは、入力語として有効な語をあらかじめ列挙しておき、
アプリケーションプログラムのユーザに選択させる仕組みです。
</P><P>

たとえば、人名を検索するのために、次のような複合検索があったとします。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>入力語 0: 国・地域
入力語 1: 時代
入力語 2: 性別
入力語 3: キーワード
入力語 4: キーワード
</pre></td></tr></table></P><P>

このうち、入力語 3 の「性別」には、入力語として有効な語は「男」と「女」
の 2 つしかないでしょう。
このように、入力語として有効な語が限られている場合に、候補一覧が用意
されていることがあります。
</P><P>

候補一覧は検索のためのデータではありますが、内部構造はテキストデータ
そのものです。
ユーザに対して候補を列記した示したテキストを示し、その中の一つを選択
してもらうようになっています。
</P><P>

しかも、候補一覧のデータ構造はメニューと非常に似ており、メニューの
ような階層構造を持っています
(「<A HREF="eb-ja_9.html#SEC50">メニュー</A>」節を参照)。
たとえば、上の複合検索の入力語 2 「国・地域」にも候補の一覧を設けると
したら、最初の階層は次のようになるかも知れません。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>* 日本 (→選択)
* 日本以外のアジア (→詳細)
* ヨーロッパ (→詳細)
* 北アメリカ (→詳細)
* その他 (→詳細)
</pre></td></tr></table></P><P>

「日本」を選ぶと、そこで入力語が決定されたことになります。しかし、
それ以外の項目についてはさらに細かく分類された選択肢が用意されて
います。
ここでは、「北アメリカ」を選んでみましょう。
すると、さらに次のような候補一覧のデータが提示されます。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>* アメリカ (→選択)
* カナダ (→選択)
</pre></td></tr></table></P><P>

ここで、「アメリカ」「カナダ」を選ぶと、入力語が決定されます。
</P><P>

次に実際に、EB ライブラリを使ってこうした候補一覧を扱う方法について
説明します。
まず、アプリケーションプログラムは、複合検索の入力語が候補一覧を持って
いるかどうかを、確認する必要があるでしょう。
<CODE>eb_multi_entry_candidates()</CODE> を使うと、候補一覧データの開始位置
を取得することができます。
この関数は、候補一覧を持っていなければ <CODE>EB_ERR_NO_CANDIDATES</CODE> を
返しますので、候補一覧の有無も分かります。
(開始位置は取得せずに、有無だけを調べたいときは、
<CODE>eb_multi_entry_have_candidates()</CODE> という関数が使えます。)
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>EB_Position position;
EB_Error_Code err;

/* <CODE>mulit_id</CODE>, <CODE>entry_id</CODE> で、どの複合検索の何番目の
 * 入力語について確認するのかを指定します。*/
err = eb_multi_entry_candidates(&#38;book, multi_id, entry_id, &#38;position);
if (err == EB_ERR_NO_CANDIDATES) {
    /* この入力語には、候補一覧が用意されていない */
   return;
} else if (err != EB_SUCCESS) {
    /* それ以外のエラー */
   return;
}
</pre></td></tr></table></P><P>

後は、得られた位置 (<CODE>position</CODE>) にシークして、<CODE>eb_read_text()</CODE>
でテキストデータを読み込みます。
読み込んだテキストでは、候補となる語のそれぞれが候補開始と終了を表す
エスケープシーケンスに挟まれた形になっています。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>* &#60;候補開始シーケンス&#62; "日本" &#60;候補終了シーケンス&#62;
* &#60;候補開始シーケンス&#62; "日本以外のアジア" &#60;候補終了シーケンス&#62;
* &#60;候補開始シーケンス&#62; "ヨーロッパ" &#60;候補終了シーケンス&#62;
* &#60;候補開始シーケンス&#62; "北アメリカ" &#60;候補終了シーケンス&#62;
* &#60;候補開始シーケンス&#62; "その他" &#60;候補終了シーケンス&#62;
</pre></td></tr></table></P><P>

候補開始シーケンスに対しては、フックとして <CODE>EB_HOOK_BEGIN_CANDIDATE</CODE>
が用意されています。
終了シーケンスに対するフックは 2 種類あって、さらに次の階層へ続く場合
に呼ばれる <CODE>EB_HOOK_END_CANDIDATE_GROUP</CODE> と、その語がそのまま
入力語の候補となる場合に呼ばれる <CODE>EB_HOOK_END_GROUP_LEAF</CODE> に
分かれています。
</P><P>

次の階層のデータの開始位置は、終了シーケンスのフック関数に、引数として
渡ってきます。
(この点もメニューと同様なので、メニューの解説を参考にして下さい。)
</P><P>

終了シーケンスに対するフック関数の中では、<CODE>eb_current_candidate()</CODE>
という関数が使えます。
この関数は、開始シーケンスと終了シーケンスの間に挟まれた「候補」の
文字列 (ポインタ) を返します。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>const char *candidate;

candidate = eb_current_candidate(book);
</pre></td></tr></table></P><P>

<A NAME="Stop Code Issue"></A>
<HR SIZE="6">
<A NAME="SEC52"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC51"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC53"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.8 区切りコードの問題 </H2>
<!--docid::SEC52::-->
<P>

本文は、先頭から末尾まで一本の繋がったデータ列になっています。
英語辞典なら、最初の単語 `A' から最後の `zzz' までの説明が、すべて
一つの「本文」の中に書かれることになります。
</P><P>

一般に、アプリケーションプログラムがある単語を検索した際は、本文の中から
その語を説明した部分だけを抜き出して出力することになるでしょう。
しかし、困ったことに CD-ROM 書籍には、単語の説明の終わりを示す印
(エスケープシーケンス) が定義されていません。
つまり、ある語の説明部分を正確に抜き出すことは、電子ブックや EPWING 
では不可能なのです。
</P><P>

しかしながら、幸いにも市販の書籍の多くには、単語の説明の終了位置にだけ
出現する、特有のエスケープシーケンスが存在します。
もちろん、このエスケープシーケンスは本来「単語の説明の終了」を示すもの
ではなく別の用途として用いるのですが、「終了位置」として代用できる
という意味です。
</P><P>

EB ライブラリでは、この「終了位置」の印に使えるエスケープシーケンスの
ことを、<EM>区切りコード (stop code)</EM> と呼んでいます。
EB ライブラリは区切りコードを自動判定する機能を持っていますが、判定は
完璧ではないので外れることもあります。
外れると本文が途中で途切れたり、本文の続きが延々と出力されたりします。
</P><P>

その場合は、明示的に appendix
(詳しくは <CITE>ebappendix-ja</CITE> の「appendix (付録) とは」節を参照)
で区切りコードを指定することによって回避できる書籍もありますが、
残念ながら区切りコードがまったく存在しない書籍も少数ながら存在します。
区切りコードを持たない書籍に対して、有効な対処方法は今のところありません。
</P><P>

<CODE>eb_read_text()</CODE> による本文の取得では、区切りコードが検出された
時点で読み込みを止めます。
さらに繰り返し <CODE>eb_read_text()</CODE> を呼んでも、区切りコードより先の
本文は読み込めません。
</P><P>

区切りコードを検出したかどうかの判定には、<CODE>eb_is_text_stopped()</CODE>
を使います。
この関数は、最後に読み込みを行ったテキストデータの中に、区切りコードを
検出していれば 1 を返します。
</P><P>

本文以外のテキストデータにも区切りコードの概念は存在しますので、
<CODE>eb_is_text_stopped()</CODE> を使って区切りコードを検出できます。
本文以外では EB ライブラリが確実に区切りを判別できますので、誤判定の
問題は起きません。
</P><P>

見出しにおける区切りは、それぞれの単語の見出しの終了位置となります。
メニューおよび複合検索の候補一覧では、階層化された個々のメニューデータ
の終了位置で区切りと判定されます。
(同一階層に複数個のメニューデータがあっても、個々のメニューデータで
区切られます。)
著作権表示では、全文の終了位置で区切りと判定されます。
</P><P>

<A NAME="Text Data Sample"></A>
<HR SIZE="6">
<A NAME="SEC53"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC52"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC54"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.9 サンプルプログラム </H2>
<!--docid::SEC53::-->
<P>

<A NAME="IDX244"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>/*
 * 使用方法:
 *     text &#60;book-path&#62; &#60;subbook-index&#62; &#60;number&#62;
 * 例:
 *     text /cdrom 0 10
 * 説明:
 *     &#60;book-path&#62; で指定した CD-ROM 書籍から特定の副本を選び、本文
 *     の先頭から &#60;number&#62; 個分の単語の説明を出力します。
 *
 *     &#60;subbook-index&#62; には、検索対象の副本のインデックスを指定しま
 *     す。インデックスは、書籍の最初の副本から順に 0、1、2 ... に
 *     なります。
 */
#include "config.h"

#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;

#include &#60;eb/eb.h&#62;
#include &#60;eb/error.h&#62;
#include &#60;eb/text.h&#62;

#define MAXLEN_TEXT 1023

int
main(argc, argv)
    int argc;
    char *argv[];
{
    EB_Error_Code error_code;
    EB_Book book;
    EB_Subbook_Code subbook_list[EB_MAX_SUBBOOKS];
    int subbook_count;
    int subbook_index;
    EB_Position text_position;
    char text[MAXLEN_TEXT + 1];
    ssize_t text_length;
    int text_count;
    int i;

    /* コマンド行引数をチェック。*/
    if (argc != 4) {
        fprintf(stderr, "Usage: %s book-path subbook-index number\n",
            argv[0]);
        exit(1);
    }
    text_count = atoi(argv[3]);

    /* EB ライブラリと `book' を初期化。*/
    eb_initialize_library();
    eb_initialize_book(&#38;book);

    /* 書籍を `book' に結び付ける。*/
    error_code = eb_bind(&#38;book, argv[1]);
    if (error_code != EB_SUCCESS) {
        fprintf(stderr, "%s: failed to bind the book, %s: %s\n",
            argv[0], eb_error_message(error_code), argv[1]);
        goto die;
    }

    /* 副本の一覧を取得。*/
    error_code = eb_subbook_list(&#38;book, subbook_list, &#38;subbook_count);
    if (error_code != EB_SUCCESS) {
        fprintf(stderr, "%s: failed to get the subbbook list, %s\n",
            argv[0], eb_error_message(error_code));
        goto die;
    }

    /* 副本のインデックスを取得。*/
    subbook_index = atoi(argv[2]);

    /*「現在の副本 (current subbook)」を設定。*/
    if (eb_set_subbook(&#38;book, subbook_list[subbook_index]) &#60; 0) {
        fprintf(stderr, "%s: failed to set the current subbook, %s\n",
            argv[0], eb_error_message(error_code));
        goto die;
    }

    /* テキストの開始位置を取得。*/
    error_code = eb_text(&#38;book, &#38;text_position);
    if (error_code != EB_SUCCESS) {
        fprintf(stderr, "%s: failed to get text information, %s\n",
            argv[0], eb_error_message(error_code));
        goto die;
    }

    /* テキストをシーク。*/
    error_code = eb_seek_text(&#38;book, &#38;text_position);
    if (error_code != EB_SUCCESS) {
        fprintf(stderr, "%s: failed to seek text, %s\n",
            argv[0], eb_error_message(error_code));
        goto die;
    }

    i = 0;
    while (i &#60; text_count) {
        /* テキストを取得。*/
        error_code = eb_read_text(&#38;book, NULL, NULL, NULL, MAXLEN_TEXT,
            text, &#38;text_length);
        if (error_code != EB_SUCCESS) {
            fprintf(stderr, "%s: failed to read text, %s\n",
                argv[0], eb_error_message(error_code));
            goto die;
        }
        fputs(text, stdout);

        if (!eb_is_text_stopped(&#38;book))
            continue;

        fputs("\n----------------------------------------\n", stdout);

        /* 次の単語の説明へ移動。*/
        error_code = eb_forward_text(&#38;book, NULL);
        if (error_code == EB_ERR_END_OF_CONTENT)
            fputs("\n[END]\n", stdout);
        else if (error_code != EB_SUCCESS) {
            fprintf(stderr, "%s: failed to read text, %s\n",
                argv[0], eb_error_message(error_code));
            goto die;
        }
        i++;
    }
        
    /* 書籍と EB ライブラリの利用を終了。*/
    eb_finalize_book(&#38;book);
    eb_finalize_library();
    exit(0);

    /* エラー発生で終了するときの処理。*/
  die:
    eb_finalize_book(&#38;book);
    eb_finalize_library();
    exit(1);
}
</pre></td></tr></table></P><P>

<A NAME="Text Data Types"></A>
<HR SIZE="6">
<A NAME="SEC54"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC53"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC55"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.10 データ型の詳細 </H2>
<!--docid::SEC54::-->
<P>

この節で説明しているデータ型を使うには、次のようにヘッダファイルを
読み込んで下さい。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;eb/eb.h&#62;
</pre></td></tr></table></P><P>

<A NAME="IDX245"></A>
<DL>
<DT><U>Data type:</U> <B>EB_Hook_Code</B>
<DD><A NAME="IDX246"></A>
<A NAME="IDX247"></A>
</P><P>

データ型 <CODE>EB_Hook_Hook</CODE> は、フックの設定位置コードを表します。
</P><P>

この型は符合付き整数型の別名として定義されていますので、2 つのコードを
2 項演算子 <CODE>==</CODE> と <CODE>!=</CODE> で一致比較することができます。
</P><P>

EB ライブラリでは、全部で <CODE>EB_NUMBER_OF_HOOKS</CODE> 個のフックコードを
定義しています。
定義されている設定位置コードの一覧については、
次の節 (「<A HREF="eb-ja_9.html#SEC56">フックコードの一覧</A>」節を参照)
を参照して下さい。
</DL>
</P><P>

<A NAME="IDX248"></A>
<DL>
<DT><U>Data type:</U> <B>EB_Hook</B>
<DD><A NAME="IDX249"></A>
</P><P>

データ型 <CODE>EB_Hook</CODE> は、フックコードとそれに対応するフック関数の組
を表します。
内部構造は、次のように定義されています。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>typedef struct EB_Hook_Struct EB_Hook;

struct EB_Hook_Struct {
    EB_Hook_Code code;
    EB_Error_Code (*function)(EB_Book *, EB_Appendix *, void *,
        EB_Hook_Code, int, const unsigned int *);
};
</pre></td></tr></table></P><P>

アプリケーションプログラムは、直接 <CODE>EB_Hook</CODE> オブジェクトのメンバ
を参照したり、セットしたりしても構いません。
</DL>
</P><P>

<A NAME="IDX250"></A>
<DL>
<DT><U>Data type:</U> <B>EB_Hookset</B>
<DD><A NAME="IDX251"></A>
</P><P>

データ型 <CODE>EB_Hookset</CODE> は、フック一式を表します。
EB ライブラリで利用可能なすべてのフック設定位置に対して、どのような
フック関数を指定するのかを記録するための型です。
</P><P>

<CODE>EB_Hookiset</CODE> オブジェクトの操作は、すべて EB ライブラリが用意
している関数で行います。
アプリケーションプログラムは、直接 <CODE>EB_Hookset</CODE> オブジェクトの
メンバを参照したり、セットしたりすべきではありません。
</P><P>

<CODE>EB_Hookset</CODE> オブジェクトを使用する際は、まずそのオブジェクトに
対して <CODE>eb_initialize_hookset()</CODE> を呼んで初期化しなくては
なりません。
</DL>
</P><P>

<A NAME="Hook Function Details"></A>
<HR SIZE="6">
<A NAME="SEC55"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC54"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC56"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.11 フック関数の詳細 </H2>
<!--docid::SEC55::-->
<P>

この節では、フック関数の仕様について記します。
</P><P>

まず、フック関数を呼び出す <CODE>eb_read_text()</CODE> および
<CODE>eb_read_heading()</CODE> のプロトタイプは次のようになっています。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>EB_Error_Code
eb_read_text(EB_Book *book, EB_Appendix *appendix,
    EB_Hookset *hookset, void *container, size_t text_max_length,
    char *text, ssize_t *text_length)
</pre></td></tr></table></P><P>

一方、フック関数のプロトタイプは、次のようになっています。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>EB_Error_Code
hook_function(EB_Book *book, EB_Appendix *appendix, void *container,
    EB_Hook_Code code, int argc, const unsigned int *argv);
</pre></td></tr></table></P><P>

引数 <VAR>book</VAR>, <VAR>appendix</VAR>, <VAR>container</VAR> は、
<CODE>eb_read_text()</CODE> あるいは <CODE>eb_read_heading()</CODE> に渡された値が
そのままフック関数にも渡ってきます。
</P><P>

<VAR>appendix</VAR> というのは、書籍に対する補助データを提供するオブジェクト
です
(appendix (付録) について詳しくは <CITE>ebappendix-ja</CITE> の「appendix (付録) とは」節を参照)。
</P><P>

引数 <VAR>container</VAR> は、アプリケーションプログラムからフック関数に
何かデータを渡したいときに使います。
</P><P>

最後の <VAR>argc</VAR> と <VAR>argv</VAR> には、加工前のテキストデータが渡されます。
文字に対するフックでは、文字コード番号が渡ってきます。
エスケープシーケンスに対するフックでは、そのシーケンス自体のコード
(<SAMP>`1f'</SAMP> で始まるコード) と、もしあればエスケープシーケンスへの引数を
が渡ってきます。
個々のフックにおいて、<VAR>argc</VAR> と <VAR>argv</VAR> にどうような値が渡って
くるのか、詳しくは 「<A HREF="eb-ja_9.html#SEC56">フックコードの一覧</A>」節を参照。
</P><P>

フック関数の中から次に挙げる関数を呼び出すことで、テキストデータへの
書き込みを行うことができます。
</P><P>

<UL>
<LI><CODE>eb_write_text()</CODE>
<LI><CODE>eb_write_text_string()</CODE>
<LI><CODE>eb_write_text_byte1()</CODE>
<LI><CODE>eb_write_text_byte2()</CODE>
</UL>
<P>

これらの関数の仕様に関して詳しくは
「<A HREF="eb-ja_9.html#SEC59">[テキストデータ] 関数の詳細</A>」節を参照。
</P><P>

フック関数が <CODE>EB_SUCCESS</CODE> 以外の値を返すと、フック関数を呼び出した
<CODE>eb_read_text()</CODE>, <CODE>eb_read_heading()</CODE> はエラーが発生したもの
と見なし、そのエラーコードを
そのままアプリケーションプログラムに返します。
</P><P>

フック関数の中では、<VAR>book</VAR> に対して以下の関数を呼び出しては
いけません。
呼び出したときの動作は、未定義です。
</P><P>

<UL>
<LI><CODE>eb_seek_text()</CODE>
<LI><CODE>eb_read_text()</CODE>
<LI><CODE>eb_read_heading()</CODE>
<LI><CODE>eb_read_rawtext()</CODE>
<LI><CODE>eb_forward_text()</CODE>
<LI><CODE>eb_backward_text()</CODE>
<LI><CODE>eb_set_subbook()</CODE>
<LI><CODE>eb_unset_subbook()</CODE>
<LI><CODE>eb_load_all_subbook()</CODE>
<LI><CODE>eb_bind()</CODE>
<LI><CODE>eb_finalize_book()</CODE>
<LI><CODE>eb_finalize_library()</CODE>
</UL>
<P>

<A NAME="Hook Code List"></A>
<HR SIZE="6">
<A NAME="SEC56"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC55"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC57"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.12 フックコードの一覧 </H2>
<!--docid::SEC56::-->
<P>

この節で説明しているフックコードを使うには、次のようにヘッダファイルを
読み込んで下さい。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;eb/text.h&#62;
</pre></td></tr></table></P><P>

<A NAME="IDX252"></A>
<DL>
<DT><U>EB_HOOK_NULL:</U> <B></B>
<DD><A NAME="IDX253"></A>
</P><P>

<CODE>EB_HOOK_NULL</CODE> は厳密にはフックではなく、<CODE>eb_set_hooks()</CODE> で
複数のフック関数を登録する際に、<CODE>EB_Hook</CODE> 配列の末尾の要素を示す
ために用います。
このフックコードに対して、フック関数は登録できません。
</P><P>

詳しくは、「<A HREF="eb-ja_9.html#SEC59">[テキストデータ] フック関数の詳細</A>」節を参照。
</DL>
</P><P>

<A NAME="IDX254"></A>
<DL>
<DT><U>EB_HOOK_INITIALIZE:</U> <B></B>
<DD><A NAME="IDX255"></A>
</P><P>

<CODE>EB_HOOK_INITIALIZE</CODE> は、<CODE>eb_seek_text()</CODE> を呼び出した直後の
最初の <CODE>eb_read_text()</CODE>, <CODE>eb_read_heading()</CODE> の呼び出し時に
処理されます。
何か初期化処理をしたいときに、使うと良いでしょう。
</P><P>

このフックが、フック関数に渡す <CODE>argc</CODE> は 0 です。
フック関数を登録していない状態では、このフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX256"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_NARROW:</U> <B></B>
<DD><A NAME="IDX257"></A>
<DT><U>EB_HOOK_END_NARROW:</U> <B></B>
<DD><A NAME="IDX258"></A>
<A NAME="IDX259"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_NARROW</CODE> および <CODE>EB_HOOK_END_NARROW</CODE> は、
半角表示の開始と終了を表すエスケープシーケンスに対するフックです。
</P><P>

どちらのフックも、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、
<CODE>EB_HOOK_BEGIN_NARROW</CODE> なら <SAMP>`0x1f04'</SAMP>、
<CODE>EB_HOOK_END_NARROW</CODE> なら <SAMP>`0x1f05'</SAMP> になります。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX260"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_SUBSCRIPT:</U> <B></B>
<DD><A NAME="IDX261"></A>
<DT><U>EB_HOOK_END_SUBSCRIPT:</U> <B></B>
<DD><A NAME="IDX262"></A>
<A NAME="IDX263"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_SUBSCRIPT</CODE> および <CODE>EB_HOOK_END_SUBSCRIPT</CODE> は、
下付き表示の開始と終了を表すエスケープシーケンスに対するフックです。
</P><P>

どちらのフックも、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> の値はエスケープシーケンスのコードそのもので、
<CODE>EB_HOOK_BEGIN_SUBSCRIPT</CODE> なら <SAMP>`0x1f06'</SAMP>、
<CODE>EB_HOOK_END_SUBSCRIPT</CODE> なら <SAMP>`0x1f07'</SAMP> になります。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに
何も書き込みません。
</DL>
</P><P>

<A NAME="IDX264"></A>
<DL>
<DT><U>EB_HOOK_SET_INDENT:</U> <B></B>
<DD><A NAME="IDX265"></A>
</P><P>

<CODE>EB_HOOK_SET_INDENT</CODE> は、テキストデータの行頭の字下げ指定を表す
エスケープシーケンスに対するフックです。
</P><P>

このフックが、フック関数に渡す <CODE>argc</CODE> は 2 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f09'</SAMP> 
になります。
<CODE>argv[1]</CODE> が、字下げの量を表します。
</P><P>

字下げの量の単位が、何であるのかは不明です。
また、字下げ量の最小値は、0 の場合と 1 の場合の二通りがあります。
いずれにしろ、字下げは 1 ずつ増えたり減ったりします。
</P><P>

フック関数を登録していない状態では、このフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX266"></A>
<DL>
<DT><U>EB_HOOK_NEWLINE:</U> <B></B>
<DD><A NAME="IDX267"></A>
</P><P>

<CODE>EB_HOOK_SET_NEWLINE</CODE> は、改行を表すエスケープシーケンスに対する
フックです。
</P><P>

ただし、<CODE>eb_read_heading()</CODE> (見出しの読み込み) による処理では、
改行を表すエスケープシーケンスは区切りコードとしても扱われます。
そのため、エスケープシーケンスが見つかってもこのフックの処理は行われず、
ただちに読み込み処理は終了します。
</P><P>

このフックが、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f0a'</SAMP> に
なります。
</P><P>

フック関数を登録していない状態では、このフックはテキストデータに何も
書き込みませんが、<CODE>eb_initialize_hookset()</CODE> で <CODE>EB_Hook</CODE> 
オブジェクトを初期化すると、フック関数として <CODE>eb_hook_newline()</CODE>
が自動的に登録されます。
</DL>
</P><P>

<A NAME="IDX268"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_SUPERSCRIPT:</U> <B></B>
<DD><A NAME="IDX269"></A>
<DT><U>EB_HOOK_END_SUPERSCRIPT:</U> <B></B>
<DD><A NAME="IDX270"></A>
<A NAME="IDX271"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_SUPERSCRIPT</CODE> および <CODE>EB_HOOK_END_SUPERSCRIPT</CODE>
は、上付き表示の開始と終了を表すエスケープシーケンスに対するフックです。
</P><P>

どちらのフックも、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、
<CODE>EB_HOOK_BEGIN_SUPERSCRIPT</CODE> なら <SAMP>`0x1f0e'</SAMP>、
<CODE>EB_HOOK_END_SUPERSCRIPT</CODE> なら <SAMP>`0x1f0f'</SAMP> になります。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX272"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_NO_NEWLINE:</U> <B></B>
<DD><A NAME="IDX273"></A>
<DT><U>EB_HOOK_END_NO_NEWLINE:</U> <B></B>
<DD><A NAME="IDX274"></A>
<A NAME="IDX275"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_NO_NEWLINE</CODE> および <CODE>EB_HOOK_END_NO_NEWLINE</CODE> は、
改行禁止の開始と終了を表すエスケープシーケンスに対するフックです。
</P><P>

どちらのフックも、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、
<CODE>EB_HOOK_BEGIN_NO_NEWLINE</CODE> なら <SAMP>`0x1f10'</SAMP>、
<CODE>EB_HOOK_END_NO_NEWLINE</CODE> なら <SAMP>`0x1f11'</SAMP> になります。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX276"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_EMPHASIS:</U> <B></B>
<DD><A NAME="IDX277"></A>
<DT><U>EB_HOOK_END_EMPHASIS:</U> <B></B>
<DD><A NAME="IDX278"></A>
<A NAME="IDX279"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_EMPHASIS</CODE> および <CODE>EB_HOOK_END_EMPHASIS</CODE> は、
強調表示の開始と終了を表すエスケープシーケンスに対するフックです。
</P><P>

どちらのフックも、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、
<CODE>EB_HOOK_BEGIN_EMPHASIS</CODE> なら <SAMP>`0x1f12'</SAMP>、
<CODE>EB_HOOK_END_EMPHASIS</CODE> なら <SAMP>`0x1f13'</SAMP> になります。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX280"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_CANDIDATE:</U> <B></B>
<DD><A NAME="IDX281"></A>
<DT><U>EB_HOOK_END_CANDIDATE_LEAF:</U> <B></B>
<DD><A NAME="IDX282"></A>
<DT><U>EB_HOOK_END_CANDIDATE_GROUP:</U> <B></B>
<DD><A NAME="IDX283"></A>
<A NAME="IDX284"></A>
<A NAME="IDX285"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_CANDIDATE</CODE> は、複合検索の候補となる語の開始を表す
エスケープシーケンスに対するフックです。
</P><P>

それに対して、終了を表すエスケープシーケンスに対するフックは 2 種類あり
ます。
一つは <CODE>EB_HOOK_END_CANDIDATE_LEAF</CODE> で、候補となる語が実際に検索の
入力語として使えるものであることを示します。
もう一つは <CODE>EB_HOOK_END_CANDIDATE_GROUP</CODE> で、候補となる語はさらに
細かい選択肢に分かれていることを示します。
(したがって、候補となる語を検索の入力語として使うことはできません。)
</P><P>

フック <CODE>EB_HOOK_BEGIN_CANDIDATES</CODE> が、フック関数に渡す <CODE>argc</CODE>
は 1 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f43'</SAMP>
になります。
</P><P>

フック <CODE>EB_HOOK_END_CANDIDATE_LEAF</CODE> および
<CODE>EB_HOOK_END_CANDIDATE_GROUP</CODE> が、フック関数に渡す <CODE>argc</CODE> は
3 です。
どちらのフックも、<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、
<SAMP>`0x1f63'</SAMP> になります。
フック <CODE>EB_HOOK_END_CANDIDATE_GROUP</CODE> の <CODE>argv[1]</CODE> と
<CODE>argv[2]</CODE> は、次の階層の候補一覧データの開始ページ番号とオフセット
です。
これは、<CODE>EB_Position</CODE> オブジェクト
(「<A HREF="eb-ja_8.html#SEC42">[検索] データ型の詳細</A>」節を参照)
の <CODE>page</CODE> および <CODE>offset</CODE> メンバの値に相当します。
フック <CODE>EB_HOOK_END_CANDIDATE_LEAF</CODE> では、<CODE>argv[1]</CODE>,
<CODE>argv[2]</CODE> は 2 つとも 0 になっています。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX286"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_REFERENCE:</U> <B></B>
<DD><A NAME="IDX287"></A>
<DT><U>EB_HOOK_END_REFERENCE:</U> <B></B>
<DD><A NAME="IDX288"></A>
<A NAME="IDX289"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_REFERENCE</CODE> および <CODE>EB_HOOK_END_REFERENCE</CODE> は、
別位置のテキストデータの参照開始と終了を表すエスケープシーケンスに
対するフックです。
</P><P>

フック <CODE>EB_HOOK_BEGIN_REFERENCE</CODE> が、フック関数に渡す <CODE>argc</CODE>
は 2 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f42'</SAMP>
になります。
<CODE>argv[1]</CODE> の意味は不明です。
</P><P>

<CODE>EB_HOOK_END_REFERENCE</CODE> が、フック関数に渡す <CODE>argc</CODE> は 3 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f62'</SAMP>
になります。
<CODE>argv[1]</CODE> と <CODE>argv[2]</CODE> は、参照先のページ番号とオフセットです。
これは、<CODE>EB_Position</CODE> オブジェクト
(「<A HREF="eb-ja_8.html#SEC42">[検索] データ型の詳細</A>」節を参照)
の <CODE>page</CODE> および <CODE>offset</CODE> メンバの値に相当します。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX290"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_KEYWORD:</U> <B></B>
<DD><A NAME="IDX291"></A>
<DT><U>EB_HOOK_END_KEYWORD:</U> <B></B>
<DD><A NAME="IDX292"></A>
<A NAME="IDX293"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_KEYWORD</CODE> および <CODE>EB_HOOK_END_KEYWORD</CODE> は、
検索キーの開始と終了を表すエスケープシーケンスに対するフックです。
</P><P>

フック <CODE>EB_HOOK_BEGIN_KEYWORD</CODE> が、フック関数に渡す <CODE>argc</CODE> は
2 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f41'</SAMP>
になります。
<CODE>argv[1]</CODE> の意味は不明です。
</P><P>

<CODE>EB_HOOK_END_KEYWORD</CODE> は、フック関数に 1 個の引数を渡します。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f61'</SAMP>
になります。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX294"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_DECORATION:</U> <B></B>
<DD><A NAME="IDX295"></A>
<DT><U>EB_HOOK_END_DECORATION:</U> <B></B>
<DD><A NAME="IDX296"></A>
<A NAME="IDX297"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_DECORATION</CODE> および <CODE>EB_HOOK_END_DECORATION</CODE>
は、文字修飾の開始と終了を表すエスケープシーケンスに対するフックです。
</P><P>

フック <CODE>EB_HOOK_BEGIN_DECORATION</CODE> が、フック関数に渡す <CODE>argc</CODE>
は 2 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1fe0'</SAMP>
になります。
<CODE>argv[1]</CODE> の意味は不明です。
</P><P>

<CODE>EB_HOOK_END_KEYWORD</CODE> は、フック関数に 1 個の引数を渡します。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1fe1'</SAMP>
になります。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX298"></A>
<DL>
<DT><U>EB_HOOK_NARROW_FONT:</U> <B></B>
<DD><A NAME="IDX299"></A>
<DT><U>EB_HOOK_WIDE_FONT:</U> <B></B>
<DD><A NAME="IDX300"></A>
<A NAME="IDX301"></A>
</P><P>

<CODE>EB_HOOK_NARROW_FONT</CODE> および <CODE>EB_HOOK_WIDE_FONT</CODE> は、それぞれ
半角外字と全角外字に対するフックです。
</P><P>

どちらのフックも、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> は、外字の文字番号を表します。
</P><P>

フック関数を登録していない状態では、このフックはテキストデータに何も
書き込みませんが、<CODE>eb_initialize_hookset()</CODE> で <CODE>EB_Hook</CODE> 
オブジェクトを初期化すると、フック関数として
<CODE>eb_hook_narrow_character_text()</CODE> および
<CODE>eb_hook_wide_character_text()</CODE> が自動的に登録されます。
</DL>
</P><P>

<A NAME="IDX302"></A>
<DL>
<DT><U>EB_HOOK_ISO8859_1:</U> <B></B>
<DD><A NAME="IDX303"></A>
</P><P>

<CODE>EB_HOOK_ISO8859_1</CODE> は、ISO 8859-1 (ラテン文字 1) 文字に対する
フックです。
</P><P>

このフックが、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> は、ISO 8859-1 の文字番号を表します。
</P><P>

フック関数を登録していない状態では、<CODE>argv[0]</CODE> の値をそのまま
テキストデータに書き込みます。
つまり、文字はそのまま ISO 8859-1 として、1 バイト書き込まれます。
</P><P>

このフックが利用されるのは、処理中の書籍の文字コードが
<CODE>EB_CHARCODE_ISO8859_1</CODE> の場合だけです。
</DL>
</P><P>

<A NAME="IDX304"></A>
<DL>
<DT><U>EB_HOOK_NARROW_JISX0208:</U> <B></B>
<DD><A NAME="IDX305"></A>
<DT><U>EB_HOOK_WIDE_JISX0208:</U> <B></B>
<DD><A NAME="IDX306"></A>
<A NAME="IDX307"></A>
</P><P>

<CODE>EB_HOOK_NARROW_JISX0208</CODE> と <CODE>EB_HOOK_WIDE_JISX0208</CODE> は、
半角および全角の JIS X 0208 (日本語のかな漢字) 文字に対するフックです。
</P><P>

どちらのフックも、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> は、JIS X 0208 の文字を日本語 EUC で表現したときの文字番号
を表します。
</P><P>

フック関数を登録していない状態では、<CODE>argv[0]</CODE> の値をそのまま
テキストデータに書き込みます。
つまり、文字はそのまま日本語 EUC として、2 バイト書き込まれます。
</P><P>

このフックが利用されるのは、
処理中の書籍の文字コードが <CODE>EB_CHARCODE_JISX0208</CODE> か
<CODE>EB_CHARCODE_JISX0208_GB2312</CODE> の場合だけです。
</DL>
</P><P>

<A NAME="IDX308"></A>
<DL>
<DT><U>EB_HOOK_GB2312:</U> <B></B>
<DD><A NAME="IDX309"></A>
</P><P>

<CODE>EB_HOOK_GB2312</CODE> は、GB 2312 (中国語の簡体字) 文字に対するフック
です。
</P><P>

このフックが、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> は、GB 2312 の文字を中国語 EUC で表現したときの文字番号
を表します。
</P><P>

フック関数を登録していない状態では、<CODE>argv[0]</CODE> の値をそのまま
テキストデータに書き込みます。
つまり、文字はそのまま中国語 EUC として、2 バイト書き込まれます。
</P><P>

このフックが利用されるのは、処理中の書籍の文字コードが
<CODE>EB_CHARCODE_JISX0208_GB2312</CODE> の場合だけです。
</DL>
</P><P>

<A NAME="IDX310"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_MONO_GRAPHIC:</U> <B></B>
<DD><A NAME="IDX311"></A>
<DT><U>EB_HOOK_END_MONO_GRAPHIC:</U> <B></B>
<DD><A NAME="IDX312"></A>
<A NAME="IDX313"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_MONO_GRAPHIC</CODE> および <CODE>EB_HOOK_END_MONO_GRAPIHC</CODE>
は、モノクロ図版の参照開始と終了を表すエスケープシーケンスに対する
フックです。
</P><P>

フック <CODE>EB_HOOK_BEGIN_MONO_GRAPHIC</CODE> が、フック関数に渡す <CODE>argc</CODE>
は 4 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f32'</SAMP>
か <SAMP>`0x1f44'</SAMP> のいずれかになります。
<CODE>argv[2]</CODE> と <CODE>argv[3]</CODE> は、図版の高さと幅 (ピクセル数) を意味
します。
ただし、電子ブックのモノクロ図版 (最初の引数が <SAMP>`0x1f32'</SAMP> の場合) 
には、図版の高さと幅の情報が欠けているので、値はどちらも 0 になります。
<CODE>argv[1]</CODE> の意味は不明です。
</P><P>

<CODE>EB_HOOK_END_MONO_GRAPHIC</CODE> が、フック関数に渡す <CODE>argc</CODE> は 3
です。
<CODE>argv[0]</CODE> は、エスケープシーケンスのコードそのものです。
<CODE>EB_HOOK_BEGIN_MONO_GRAPHIC</CODE> の <CODE>argv[0]</CODE> が <SAMP>`0x1f32'</SAMP>
なら、<CODE>EB_HOOK_END_MONO_GRAPHIC</CODE> の <CODE>argv[0]</CODE> は <SAMP>`0x1f52'</SAMP>
になり、<SAMP>`0x1f44'</SAMP> なら <SAMP>`0x1f64'</SAMP> になります。
<CODE>argv[1]</CODE> と <CODE>argv[2]</CODE> は、図版データのページ番号とオフセット
です。
これは、<CODE>EB_Position</CODE> オブジェクト
(「<A HREF="eb-ja_8.html#SEC42">[検索] データ型の詳細</A>」節を参照)
の <CODE>page</CODE> および <CODE>offset</CODE> メンバの値に相当します。
</P><P>

図版データの取り出し方については、「<A HREF="eb-ja_11.html#SEC72">モノクロ図版</A>」節を参照
を参照してください。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX314"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_GRAY_GRAPHIC:</U> <B></B>
<DD><A NAME="IDX315"></A>
<DT><U>EB_HOOK_END_GRAY_GRAPHIC:</U> <B></B>
<DD><A NAME="IDX316"></A>
<A NAME="IDX317"></A>
</P><P>

これらのフック名称は、グレースケール図版のために予約されていますが、
EB ライブラリ 4.0 ではまだ対応していません。
</DL>
</P><P>

<A NAME="IDX318"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_COLOR_BMP:</U> <B></B>
<DD><A NAME="IDX319"></A>
<DT><U>EB_HOOK_BEGIN_COLOR_JPEG:</U> <B></B>
<DD><A NAME="IDX320"></A>
<DT><U>EB_HOOK_END_COLOR_GRAPHIC:</U> <B></B>
<DD><A NAME="IDX321"></A>
<A NAME="IDX322"></A>
<A NAME="IDX323"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_COLOR_BMP</CODE> と <CODE>EB_HOOK_COLOR_JPEG</CODE> は、
それぞれ BMP 形式と JPEG 形式のカラー図版の参照開始を表す
エスケープシーケンスに対するフックです。
参照開始のフックは BMP と JPEG とでフックが分かれていますが、終了の
フックは共通で、<CODE>EB_HOOK_END_COLOR_GRAPIHC</CODE> になります。
</P><P>

フック <CODE>EB_HOOK_BEGIN_COLOR_BMP</CODE> と <CODE>EB_HOOK_COLOR_JPEG</CODE> が、
フック関数に渡す <CODE>argc</CODE> は 4 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f4d'</SAMP>
になります。
<CODE>argv[2]</CODE> と <CODE>argv[3]</CODE> は、図版の幅と高さ (ピクセル数) を意味
します。
<CODE>argv[1]</CODE> の意味は不明です。
</P><P>

フック <CODE>EB_HOOK_END_COLOR_BMP</CODE> が、フック関数に渡す <CODE>argc</CODE> は
3 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f6d'</SAMP> に
なります。
<CODE>argv[1]</CODE> と <CODE>argv[2]</CODE> は、図版データのページ番号とオフセットです。
これは、<CODE>EB_Position</CODE> オブジェクト
(「<A HREF="eb-ja_8.html#SEC42">[検索] データ型の詳細</A>」節を参照)
の <CODE>page</CODE> および <CODE>offset</CODE> メンバの値に相当します。
</P><P>

図版データの取り出し方については、「<A HREF="eb-ja_11.html#SEC73">カラー図版</A>」節を参照
を参照してください。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX324"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_IN_COLOR_BMP:</U> <B></B>
<DD><A NAME="IDX325"></A>
<DT><U>EB_HOOK_BEGIN_IN_COLOR_JPEG:</U> <B></B>
<DD><A NAME="IDX326"></A>
<DT><U>EB_HOOK_END_IN_COLOR_GRAPHIC:</U> <B></B>
<DD><A NAME="IDX327"></A>
<A NAME="IDX328"></A>
<A NAME="IDX329"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_IN_COLOR_BMP</CODE> と <CODE>EB_HOOK_IN_COLOR_JPEG</CODE> は、
それぞれ BMP 形式と JPEG 形式のインラインカラー図版の参照開始を表す
エスケープシーケンスに対するフックです。
参照開始のフックは BMP と JPEG とでフックが分かれていますが、終了の
フックは共通で、<CODE>EB_HOOK_END_IN_COLOR_GRAPIHC</CODE> になります。
</P><P>

フック <CODE>EB_HOOK_BEGIN_IN_COLOR_BMP</CODE> と <CODE>EB_HOOK_IN_COLOR_JPEG</CODE>
が、フック関数に渡す <CODE>argc</CODE> は 4 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f3c'</SAMP>
になります。
<CODE>argv[2]</CODE> と <CODE>argv[3]</CODE> は、図版の幅と高さ (ピクセル数) を意味
します。
<CODE>argv[1]</CODE> の意味は不明です。
</P><P>

フック <CODE>EB_HOOK_END_IN_COLOR_BMP</CODE> が、フック関数に渡す <CODE>argc</CODE>
は 3 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f5c'</SAMP>
になります。
<CODE>argv[1]</CODE> と <CODE>argv[2]</CODE> は、図版データのページ番号とオフセット
です。
これは、<CODE>EB_Position</CODE> オブジェクト
(「<A HREF="eb-ja_8.html#SEC42">[検索] データ型の詳細</A>」節を参照)
の <CODE>page</CODE> および <CODE>offset</CODE> メンバの値に相当します。
</P><P>

図版データの取り出し方については、「<A HREF="eb-ja_11.html#SEC73">カラー図版</A>」節を参照
を参照してください。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX330"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_WAVE:</U> <B></B>
<DD><A NAME="IDX331"></A>
<DT><U>EB_HOOK_END_WAVE:</U> <B></B>
<DD><A NAME="IDX332"></A>
<A NAME="IDX333"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_WAVE</CODE> および <CODE>EB_HOOK_END_WAVE</CODE> は、
WAVE (PCM) 形式の音声データの参照開始と終了を表すエスケープシーケンス
に対するフックです。
</P><P>

フック <CODE>EB_HOOK_BEGIN_WAVE</CODE> が、フック関数に渡す <CODE>argc</CODE> は 6
です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f4a'</SAMP>
になります。
<CODE>argv[2]</CODE> と <CODE>argv[3]</CODE> は音声データの開始位置のページ番号と
オフセット、<CODE>argv[4]</CODE> と <CODE>argv[5]</CODE> は終了位置のページ番号と
オフセットをそれぞれ表します。
<CODE>argv[1]</CODE> の意味は不明です。
</P><P>

<CODE>EB_HOOK_END_WAVE</CODE> が、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f6a'</SAMP>
になります。
</P><P>

音声データの取り出し方については、「<A HREF="eb-ja_11.html#SEC74">WAVE 音声</A>」節を参照 を
参照して下さい。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="IDX334"></A>
<DL>
<DT><U>EB_HOOK_BEGIN_MPEG:</U> <B></B>
<DD><A NAME="IDX335"></A>
<DT><U>EB_HOOK_END_MPEG:</U> <B></B>
<DD><A NAME="IDX336"></A>
<A NAME="IDX337"></A>
</P><P>

<CODE>EB_HOOK_BEGIN_MPEG</CODE> および <CODE>EB_HOOK_END_MPEG</CODE> は、MPEG 形式
の動画データの参照開始と終了を表すエスケープシーケンスに対するフック
です。
</P><P>

フック <CODE>EB_HOOK_BEGIN_MPEG</CODE> が、フック関数に渡す <CODE>argc</CODE> は 6
です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f39'</SAMP>
になります。
<CODE>argv[2]</CODE> 〜 <CODE>argv[5]</CODE> は、動画データのファイル名をエンコード
した数値列になります。
<CODE>argv[1]</CODE> の意味は不明です。
</P><P>

<CODE>EB_HOOK_END_MPEG</CODE> が、フック関数に渡す <CODE>argc</CODE> は 1 です。
<CODE>argv[0]</CODE> はエスケープシーケンスのコードそのもので、<SAMP>`0x1f59'</SAMP>
になります。
</P><P>

動画データの取り出し方については、「<A HREF="eb-ja_11.html#SEC75">MPEG 動画</A>」節を参照 を
参照して下さい。
</P><P>

フック関数を登録していない状態では、これらのフックはテキストデータに何も
書き込みません。
</DL>
</P><P>

<A NAME="Hookset Access Functions"></A>
<HR SIZE="6">
<A NAME="SEC57"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC56"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC58"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.13 フックセット操作関数の詳細 </H2>
<!--docid::SEC57::-->
<P>

この節で説明している関数を使うには、次のようにヘッダファイルを読み込んで
下さい。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;eb/text.h&#62;
</pre></td></tr></table></P><P>

<A NAME="IDX338"></A>
<DL>
<DT><U>Function:</U> void <B>eb_initialize_hookset</B> <I>(EB_Hookset *<VAR>hookset</VAR>)</I>
<DD><A NAME="IDX339"></A>
</P><P>

関数 <CODE>initialize_hookset()</CODE> は、<VAR>hookset</VAR> の指す <CODE>EB_Hookset</CODE>
オブジェクトを初期化します。
<CODE>EB_Hookiset</CODE> オブジェクトに対して EB ライブラリの他の関数を呼ぶ前に、
必ずそのオブジェクトを初期化しなくてはなりません。
初期化していないオブジェクトに対して、EB ライブラリの他の関数を呼んだ
場合の動作は未定義です。
また、すでに初期化したオブジェクトに対して、再度
<CODE>eb_initialize_hookset()</CODE> を呼んではいけません。
呼んだ場合の動作は未定義です。
</P><P>

この関数は、各フックの初期値を次のようにセットします。
</P><P>

<TABLE>
<TR><TD>フック                          </TD><TD> フック関数</TD>
</TR>
<TR><TD><CODE>EB_HOOK_NARROW_JISX0208</CODE>  </TD><TD> <CODE>eb_hook_euc_to_ascii()</CODE></TD>
</TR>
<TR><TD><CODE>EB_HOOK_NARROW_FONT</CODE>      </TD><TD> <CODE>eb_hook_narrow_character_text()</CODE></TD>
</TR>
<TR><TD><CODE>EB_HOOK_WIDE_FONT</CODE>        </TD><TD> <CODE>eb_hook_wide_character_text()</CODE></TD>
</TR>
<TR><TD><CODE>EB_HOOK_NEWLINE</CODE>          </TD><TD> <CODE>eb_hook_newline()</CODE></TD>
</TR>
<TR><TD>上記以外のフック                </TD><TD> <CODE>NULL</CODE> (フック関数なし)</TD>
</TR></TABLE>
</DL>
<P>

<A NAME="IDX340"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_finalize_hookset</B> <I>(EB_Hookset *<VAR>hookset</VAR>)</I>
<DD><A NAME="IDX341"></A>
</P><P>

関数 <CODE>eb_finalize_hookset()</CODE> は、<VAR>hookset</VAR> が指す
<CODE>EB_Hooksest</CODE> オブジェクトの後始末を行います。
</P><P>

オブジェクトが割り当てて管理していたメモリは、すべて解放されます。
すべてのフックには、フック関数として <CODE>NULL</CODE> がセットされます。
</P><P>

後始末をしたオブジェクトに対して <CODE>eb_set_hook()</CODE>, <CODE>eb_set_hooks()</CODE>
を呼ぶことで、オブジェクトを再利用することができます。
</DL>
</P><P>

<A NAME="IDX342"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_set_hook</B> <I>(EB_Hookset *<VAR>hookset</VAR>, const EB_Hook *<VAR>hook</VAR>)</I>
<DD><A NAME="IDX343"></A>
</P><P>

関数 <CODE>eb_set_hook()</CODE> は、<VAR>hookset</VAR> が指す <CODE>EB_Hooksest</CODE>
オブジェクトに、フック関数を一つ登録します。
登録するフックの種類とフック関数は、<VAR>hook</VAR> で指定します。
</P><P>

同じフックコードに複数回フック関数を登録しても、有効になるのは最後に
登録したものだけですので、注意して下さい。
フック関数として <CODE>NULL</CODE> を指定すると、登録されているフックが解除
されます。
</P><P>

成功すると、この関数は <CODE>EB_SUCCESS</CODE> を返します。
失敗すると、原因を示すエラーコードを返します。
</DL>
</P><P>

<A NAME="IDX344"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_set_hooks</B> <I>(EB_Hookset *<VAR>hookset</VAR>, const EB_Hook *<VAR>hooks</VAR>)</I>
<DD><A NAME="IDX345"></A>
</P><P>

この関数は <CODE>eb_set_hook()</CODE> に似ていますが、任意の個数の
フック関数を一度に登録できる点が異なります。
</P><P>

登録するフックの種類とフック関数は、<VAR>hooks</VAR> で指定します。
<VAR>hooks</VAR> は <CODE>EB_Hook</CODE> オブジェクトの配列 (の先頭) を指して
いなければなりません。
また、この配列の末尾には、フックコード <CODE>EB_HOOK_NULL</CODE> をセット
した <CODE>EB_Hook</CODE> オブジェクトを配列要素として置く必要があります。
</P><P>

<CODE>eb_set_hooks()</CODE> は、配列の先頭から順番に、指定されたフックコード
に対してフック関数を登録していきます。
エラーが発生すると、残りのフックの登録はせずに、原因を示すエラーコード
をただちに返します。
すべてのフック関数の登録に成功すると、<CODE>EB_SUCCESS</CODE> を返します。
</DL>
</P><P>

<A NAME="Builtin Hook Functions"></A>
<HR SIZE="6">
<A NAME="SEC58"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC57"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC59"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.14 組み込みフック関数の詳細 </H2>
<!--docid::SEC58::-->
<P>

EB ライブラリは、基本的なフック関数をいくつか用意しています。
本節では、これらのフック関数についての仕様を解説します。
</P><P>

この節で説明している関数を使うには、次のようにヘッダファイルを読み込んで
下さい。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;eb/text.h&#62;
</pre></td></tr></table></P><P>

いずれのフック関数も、引数 <VAR>appendix</VAR> と <VAR>container</VAR> に
<CODE>NULL</CODE> を渡されても、動作に支障はないようになっています。
</P><P>

<A NAME="IDX346"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_hook_euc_to_ascii</B> <I>(EB_Book *<VAR>book</VAR>, EB_Appendix *<VAR>appendix</VAR>, void *<VAR>container</VAR>, EB_Hook_Code <VAR>code</VAR>, int <VAR>argc</VAR>, const unsigned int *<VAR>argv</VAR>)</I>
<DD><A NAME="IDX347"></A>
</P><P>

<CODE>eb_hook_euc_to_ascii()</CODE> は、フックコード
<CODE>EB_HOOK_NARROW_JISX0208</CODE> (半角 JIS X 0208 文字) のためのフック関数
です。
</P><P>

<CODE>EB_Hookset</CODE> オブジェクトを関数 <CODE>eb_initialiez_hookset()</CODE> で
初期化すると、この関数が自動的に登録されます。
</P><P>

このフック関数は、<CODE>argv[0]</CODE> として渡された JIS X 0208 の文字
(エンコーディングは日本語 EUC) を調べ、対応する ASCII 文字が存在すれば
その ASCII 文字をテキストデータとして書き込み、なければ JIS X 0208 の
文字をそのまま書き込みます。
</P><P>

常に <CODE>EB_SUCCESS</CODE> を返します。
</DL>
</P><P>

<A NAME="IDX348"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_hook_narrow_character_text</B> <I>(EB_Book *<VAR>book</VAR>, EB_Appendix *<VAR>appendix</VAR>, void *<VAR>container</VAR>, EB_Hook_Code <VAR>code</VAR>, int <VAR>argc</VAR>, const unsigned int *<VAR>argv</VAR>)</I>
<DD><A NAME="IDX349"></A>
<DT><U>Function:</U> EB_Error_Code <B>eb_hook_wide_character_text</B> <I>(EB_Book *<VAR>book</VAR>, EB_Appendix *<VAR>appendix</VAR>, void *<VAR>container</VAR>, EB_Hook_Code <VAR>code</VAR>, int <VAR>argc</VAR>, const unsigned int *<VAR>argv</VAR>)</I>
<DD><A NAME="IDX350"></A>
<A NAME="IDX351"></A>
</P><P>

<CODE>eb_hook_narrow_character_text()</CODE> は、フックコード
<CODE>EB_HOOK_NARROW_FONT</CODE> (半角外字) のためのフック関数です。
同様に <CODE>eb_hook_wide_character_text()</CODE> は、フックコード
<CODE>EB_HOOK_WIDE_FONT</CODE> (全角外字) のためのフック関数です。
</P><P>

<CODE>EB_Hookset</CODE> オブジェクトを関数 <CODE>eb_initialiez_hookset()</CODE> で
初期化すると、これらの関数が自動的に登録されます。
</P><P>

この関数は、<VAR>appendix</VAR> の選択中している副本が、<CODE>argv[0]</CODE> として
渡された外字の代替文字列を持っているかどうか調べます。
持っていればその文字列をテキストデータとして書き込み、持っていなければ
<SAMP>`&#60;?&#62;'</SAMP> という文字列を書き込みます。
</P><P>

<VAR>appendix</VAR> が <CODE>NULL</CODE> の場合や、付録が副本を選択中でない場合も、
代替文字列を持っていないものとして扱います。
</P><P>

この関数は、常に <CODE>EB_SUCCESS</CODE> を返します。
</DL>
</P><P>

<A NAME="IDX352"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_hook_newline</B> <I>(EB_Book *<VAR>book</VAR>, EB_Appendix *<VAR>appendix</VAR>, void *<VAR>container</VAR>, EB_Hook_Code <VAR>code</VAR>, int <VAR>argc</VAR>, const unsigned int *<VAR>argv</VAR>)</I>
<DD><A NAME="IDX353"></A>
</P><P>

<CODE>eb_hook_narrow_newline()</CODE> は、フックコード
<CODE>EB_HOOK_NEWLINE</CODE> (改行) のためのフック関数です。
</P><P>

<CODE>EB_Hookset</CODE> オブジェクトを関数 <CODE>eb_initialiez_hookset()</CODE> で
初期化すると、これらの関数が自動的に登録されます。
</P><P>

この関数は、テキストデータに <SAMP>`\n'</SAMP> を書き込みます。
常に <CODE>EB_SUCCESS</CODE> を返します。
</DL>
</P><P>

<A NAME="IDX354"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_hook_empty</B> <I>(EB_Book *<VAR>book</VAR>, EB_Appendix *<VAR>appendix</VAR>, void *<VAR>container</VAR>, EB_Hook_Code <VAR>code</VAR>, int <VAR>argc</VAR>, const unsigned int *<VAR>argv</VAR>)</I>
<DD><A NAME="IDX355"></A>
</P><P>

<CODE>eb_hook_empty()</CODE> は、何もしないフック関数です。
常に <CODE>EB_SUCCESS</CODE> を返します。
</DL>
</P><P>

<A NAME="Text Data Functions"></A>
<HR SIZE="6">
<A NAME="SEC59"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC58"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 9.15 テキストデータ操作関数の詳細 </H2>
<!--docid::SEC59::-->
<P>

この節で説明している関数を使うには、次のようにヘッダファイルを読み込んで
下さい。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;eb/text.h&#62;
</pre></td></tr></table></P><P>

<A NAME="IDX356"></A>
<DL>
<DT><U>Function:</U> int <B>eb_have_text</B> <I>(EB_Book *<VAR>book</VAR>)</I>
<DD><A NAME="IDX357"></A>
<DT><U>Function:</U> int <B>eb_have_menu</B> <I>(EB_Book *<VAR>book</VAR>)</I>
<DD><A NAME="IDX358"></A>
<DT><U>Function:</U> int <B>eb_have_copyright</B> <I>(EB_Book *<VAR>book</VAR>)</I>
<DD><A NAME="IDX359"></A>
<A NAME="IDX360"></A>
<A NAME="IDX361"></A>
</P><P>

関数 <CODE>eb_have_text()</CODE> は、<VAR>book</VAR> の選択している副本が、本文を
持っているかどうかを調べます。
同様に、<CODE>eb_have_menu()</CODE> はメニューを持っているかどうか、
<CODE>eb_have_copyright()</CODE> は著作権表示を持っているかどうか調べます。
</P><P>

いずれの関数も、持っていれば 1 を返し、持っていなければ 0 を返します。
<VAR>book</VAR> が副本を選択していない場合も 0 を返します。
</DL>
</P><P>

<A NAME="IDX362"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_text</B> <I>(EB_Book *<VAR>book</VAR>, EB_Position *<VAR>position</VAR>)</I>
<DD><A NAME="IDX363"></A>
<DT><U>Function:</U> EB_Error_Code <B>eb_menu</B> <I>(EB_Book *<VAR>book</VAR>, EB_Position *<VAR>position</VAR>)</I>
<DD><A NAME="IDX364"></A>
<DT><U>Function:</U> EB_Error_Code <B>eb_copyright</B> <I>(EB_Book *<VAR>book</VAR>, EB_Position *<VAR>position</VAR>)</I>
<DD><A NAME="IDX365"></A>
<A NAME="IDX366"></A>
<A NAME="IDX367"></A>
</P><P>

関数 <CODE>eb_text()</CODE> は、<VAR>book</VAR> が選択している副本の本文の
開始位置を <VAR>position</VAR> の指す領域に書き込みます。
同様に、<CODE>eb_menu()</CODE> はメニューの開始位置を、
<CODE>eb_have_copyright()</CODE> は著作権表示の開始位置を書き込みます。
</P><P>

成功すると、これらの関数は <CODE>EB_SUCCESS</CODE> を返します。
失敗すると、<VAR>position</VAR> に必ずシークが失敗する位置を書き込んで、
原因を示すエラーコードを返します。
</P><P>

あらかじめ、<VAR>book</VAR> 内のいずれかの副本が選択されていなくてはなりません。
<VAR>book</VAR> が副本を選択していなければ、<CODE>EB_ERR_NO_CUR_SUB</CODE> を返します。
選択中の副本が、対象となるテキストデータを持っていなければ、
<CODE>EB_ERR_NO_SUCH_SEARCH</CODE> を返します。
</DL>
</P><P>

<A NAME="IDX368"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_seek_text</B> <I>(EB_Book *<VAR>book</VAR>, const EB_Position *<VAR>position</VAR>)</I>
<DD><A NAME="IDX369"></A>
</P><P>

関数 <CODE>eb_seek_text()</CODE> は、<VAR>book</VAR> が選択している副本の
テキストデータファイルをシークします。
シーク位置は <VAR>position</VAR> で指定します。
このとき、<VAR>position</VAR> は常にファイルの先頭からの位置として解釈
されます。
(相対位置へのシーク機能は、EB ライブラリにはありません。)
</P><P>

シークを行うと、それまでに行った読み込みの状態記録がリセットされます。
<CODE>eb_read_text()</CODE>, <CODE>eb_read_heading()</CODE>, <CODE>eb_read_rawtext()</CODE>
を用いてテキストデータを読み込むには、前もってこの関数を呼び出して
おく必要があります。
</P><P>

成功すると、この関数は <CODE>EB_SUCCESS</CODE> を返します。
失敗すると、原因を示すエラーコードを返します。
</P><P>

あらかじめ、<VAR>book</VAR> 内のいずれかの副本が選択されていなくてはなりません。
<VAR>book</VAR> が副本を選択していなければ、<CODE>EB_ERR_NO_CUR_SUB</CODE> を返します。
選択中の副本にテキストデータが存在しないときは、<CODE>EB_ERR_NO_TEXT</CODE>
を返します。
</P><P>

なお、書籍によっては、テキストデータを収めたファイルには他のデータも
一緒に格納されていることがありますが、テキスト以外のデータにアクセス
しても、テキストデータの現在位置、読み込みに関する状態記録は変化しません。
</DL>
</P><P>

<A NAME="IDX370"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_tell_text</B> <I>(EB_Book *<VAR>book</VAR>, EB_Position *<VAR>position</VAR>)</I>
<DD><A NAME="IDX371"></A>
</P><P>

関数 <CODE>eb_seek_text()</CODE> は、<VAR>book</VAR> が選択している副本の
テキストデータファイルの現在のアクセス位置を返します。
</P><P>

成功すると、<VAR>position</VAR> の指す領域に現在のアクセス位置を書き込み、
<CODE>EB_SUCCESS</CODE> を返します。
失敗すると、シークが必ず失敗する位置を書き込み、原因を示すエラーコード
を返します。
</P><P>

あらかじめ、<VAR>book</VAR> 内のいずれかの副本が選択されていなくてはなりません。
<VAR>book</VAR> が副本を選択していなければ、<CODE>EB_ERR_NO_CUR_SUB</CODE> を返します。
選択中の副本にテキストデータが存在しないときは、<CODE>EB_ERR_NO_TEXT</CODE>
を返します。
</DL>
</P><P>

<A NAME="IDX372"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_read_text</B> <I>(EB_Book *<VAR>book</VAR>, EB_Appendix *<VAR>appendix</VAR>, EB_Hookset *<VAR>hookset</VAR>, void *<VAR>container</VAR>, size_t <VAR>text_max_length</VAR>, char *<VAR>text</VAR>, ssize_t *<VAR>text_length</VAR>)</I>
<DD><A NAME="IDX373"></A>
<A NAME="IDX374"></A>
<DT><U>Function:</U> EB_Error_Code <B>eb_read_heading</B> <I>(EB_Book *<VAR>book</VAR>, EB_Appendix *<VAR>appendix</VAR>, EB_Hookset *<VAR>hookset</VAR>, void *<VAR>container</VAR>, size_t <VAR>text_max_length</VAR>, char *<VAR>text</VAR>, ssize_t *<VAR>text_length</VAR>)</I>
<DD><A NAME="IDX375"></A>
</P><P>

関数 <CODE>eb_read_text()</CODE> と <CODE>eb_read_heading()</CODE> は、<VAR>book</VAR>
が選択している副本のテキストデータファイルの現在のアクセス位置からデータ
を読み込みます。
<CODE>eb_read_heading()</CODE> は見出しの読み込みに用い、<CODE>eb_read_text()</CODE>
はそれ以外のテキストデータの読み込みに用います。
</P><P>

読み込まれたテキストデータは、必要に応じて文字コードの変換
(「<A HREF="eb-ja_2.html#SEC6">文字コード</A>」節を参照) が行われた後に、<VAR>hookset</VAR>
の指すフックセットにしたがって加工されます。
<VAR>hookset</VAR> が <CODE>NULL</CODE> のときは、代わりに EB ライブラリ側で用意
している <EM>標準のフックセット (default hookset)</EM> が用いられます。
このフックセットは、<CODE>eb_initialize_hookset()</CODE> によって初期化した
だけのフックセットと等価です。
</P><P>

フックセットによって加工された後に、テキストデータは <VAR>text</VAR> の指す
領域に書き込まれ、書き込んだバイト数が <VAR>text_length</VAR> の指す領域に
書き込まれます。
<VAR>text</VAR> はナル文字で終端されますが、<VAR>text_length</VAR> にはナル文字
の分は勘定に入れません。
テキストデータは、<VAR>text_max_length</VAR> で指定されたバイト数を超えて
書き込むことはありません。
ただし、<VAR>text_max_length</VAR> にもナル文字の分は勘定に入っていません
ので、<VAR>text</VAR> は <VAR>text_max_length</VAR> + 1 バイト分のデータを格納
できる大きさが必要です。
</P><P>

どちらの関数も、成功すれば <CODE>EB_SUCCESS</CODE> を返し、失敗すれば
<VAR>text_length</VAR> の指す領域に 0 を書き込んで原因を示すエラーコード
を返します。
</P><P>

あらかじめ、<VAR>book</VAR> 内のいずれかの副本が選択されていなくてはなりません。
<VAR>book</VAR> が副本を選択していなければ、<CODE>EB_ERR_NO_CUR_SUB</CODE> を返します。
</P><P>

また、<CODE>eb_read_text()</CODE> と <CODE>eb_read_heading()</CODE> を呼び出すには、
あらかじめ <CODE>eb_seek_text()</CODE> の呼び出しを成功させ、テキストデータ
のアクセス位置がセットされた状態にしておかなくてはなりません。
シークをせずに呼び出すと、<CODE>EB_ERR_NO_PREV_SEEK</CODE> を返します。
</P><P>

逆に一度シークすれば、区切りコードが検出されるまでの間なら、関数を
繰り返し呼ぶことでテキストデータの続きを読み込むことができます。
区切りコードが検出されると、関数を呼び出しても読み込みは行われません。
その場合でも、他にエラーが発生しなければ <CODE>EB_SUCCESS</CODE> が返り、
<VAR>text</VAR> には空文字列が書き込まれます。
</P><P>

ただし、一度 <CODE>eb_read_text()</CODE> を呼び出してテキストデータを読み込み
始めたら、繰り返し呼び出す際も、<CODE>eb_read_text()</CODE> を使わなければ
なりません。
途中から <CODE>eb_read_heading()</CODE> および後述の <CODE>eb_read_rawtext()</CODE>
に切り替えて呼び出すと <CODE>EB_ERR_DIFF_CONTENT</CODE> エラーが返ります。
関数 <CODE>eb_read_heading()</CODE> についても同様です。
この制限は、再度 <CODE>eb_seek_text()</CODE> を呼び出すか、
<CODE>eb_set_subbook()</CODE> で副本を選択し直すまで続きます。
</P><P>

<VAR>appendix</VAR> が <CODE>NULL</CODE> ではなく、区切りコードの情報を持った副本
を選択中であれば、本文の区切りコードとしてその値を使用します。
それ以外の場合は、<CODE>eb_read_text()</CODE> が区切りコードを自動判別を試み
ます。
ただし、この判定は完璧なものではないので、書籍によっては変な位置で本文
が切れてしまうかも知れません。
(本文以外のテキストデータに関しては、このような問題は起きません。)
</P><P>

引数 <VAR>container</VAR> は、アプリケーションプログラムからフック関数にデータ
を渡すためのものです。
<CODE>eb_read_text()</CODE>, <CODE>eb_read_heading()</CODE> では、直接この引数の値
を参照することはありません。
</P><P>

引数 <VAR>appendix</VAR>, <VAR>container</VAR> は、そのままフック関数に渡されます。
これらの引数は <CODE>NULL</CODE> でも構いません。
(呼び出されるフック関数で支障がなければ。)
</P><P>

なお、フック関数や <CODE>eb_read_text()</CODE>, <CODE>eb_read_heading()</CODE> 
自身が文字ないしエスケープシーケンス一個分に対するデータを書き込もうと
したときに、<VAR>text</VAR> に十分な空き領域がないということが起こり得ます。
その場合、関数は途中まで <VAR>text</VAR> に書き込むことはせずに、いったん
処理を終えて戻ります。
したがって、マルチバイト文字のデータが途中で切れたりすることはありません。
</P><P>

書き込めなかった分は、当然ながら <VAR>text_length</VAR> の勘定には入りません。
書き込めなかったデータは <VAR>book</VAR> 内部に保存されているので、もう一度
<CODE>eb_read_text()</CODE>, <CODE>eb_read_heading()</CODE> を呼び出すと、前回の
呼び出しで書き込めなかったデータがまず <VAR>text</VAR> の先頭に書き込まれます。
書き込んだデータは <VAR>text_length</VAR> の勘定に入ります。
</P><P>

ただし、<CODE>book</CODE> が保存しているデータの長さが <VAR>max_text_length</VAR> を
超えていると、何も書き込まずに関数は終了します。
このとき、書き込めなかったデータは引き続き保存されます。
つまり、<CODE>text_max_length</CODE> があまりに小さく、かつ保持しているデータ
のほうが長いと、何度呼び出しても <CODE>text</CODE> への書き込みが進みませんので、
注意が必要です。
</P><P>

<CODE>eb_seek_text()</CODE> を呼び出すか、<CODE>eb_set_subbook()</CODE> で副本を選択
し直すと、保存していたデータは破棄されます。
</DL>
</P><P>

<A NAME="IDX376"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_read_rawtext</B> <I>(EB_Book *<VAR>book</VAR>, size_t <VAR>text_max_length</VAR>, char *<VAR>text</VAR>, ssize_t *<VAR>text_length</VAR>)</I>
<DD><A NAME="IDX377"></A>
</P><P>

関数 <CODE>eb_read_rawtext()</CODE> は、<VAR>book</VAR> が選択している副本の
テキストデータファイルの現在のアクセス位置からデータを読み込みます。
</P><P>

<CODE>eb_read_text()</CODE> と似ていますが、この関数はフックセットによるデータ
の加工や文字コードの変換を一切行わず、データを内部表現のまま返します。
読み込むテキストデータの種類は、何であっても構いません。
</P><P>

読み込んだテキストデータは <VAR>text</VAR> の指す領域に書き込まれ、書き込んだ
バイト数が <VAR>text_length</VAR> の指す領域に書き込まれます。
テキストデータは、<VAR>text_max_length</VAR> で指定されたバイト数を超えて
書き込むことはありません。
ただし、<CODE>eb_read_text()</CODE> と異なり、<VAR>text</VAR> はナル文字で終端
されません。
マルチバイト文字やエスケープシーケンスの途中で <VAR>text</VAR> の残り領域
が足りなくなった場合も、途中までは書き込みます。
</P><P>

処理が成功すれば <CODE>EB_SUCCESS</CODE> を返し、失敗すれば <VAR>text_length</VAR>
の指す領域に 0 を書き込んで原因を示すエラーコードを返します。
</P><P>

あらかじめ、<VAR>book</VAR> 内のいずれかの副本が選択されていなくてはなりません。
<VAR>book</VAR> が副本を選択していなければ、<CODE>EB_ERR_NO_CUR_SUB</CODE> を返します。
</P><P>

また、この関数を呼び出すには、あらかじめ <CODE>eb_seek_text()</CODE> の呼び出し
を成功させ、テキストデータのアクセス位置がセットされた状態にして
おかなくてはなりません。
シークをせずに呼び出すと、<CODE>EB_ERR_NO_PREV_SEEK</CODE> を返します。
</P><P>

この関数は、繰り返し呼び出すことで、前回読み込んだテキストデータの続き
を読み込むことができます。
ただし、区切りコードの検出を行いませんので、ひたすら呼び出しを続けると、
テキストデータファイルの末尾まで行ってしまいます。
</P><P>

一度 <CODE>eb_read_rawtext()</CODE> を呼び出してテキストデータを読み込み
始めたら、繰り返し呼び出す際も、<CODE>eb_read_rawtext()</CODE> を使わなければ
なりません。
途中から、<CODE>eb_read_text()</CODE> や <CODE>eb_read_text()</CODE> に切り替えると、
<CODE>EB_ERR_DIFF_CONTENT</CODE> エラーが返ります。
この制限は、再度 <CODE>eb_seek_text()</CODE> を呼び出すか、
<CODE>eb_set_subbook()</CODE> で副本を選択し直すまで続きます。
</DL>
</P><P>

<A NAME="IDX378"></A>
<DL>
<DT><U>Function:</U> int <B>eb_is_text_stopped</B> <I>(EB_Book *<VAR>book</VAR>)</I>
<DD><A NAME="IDX379"></A>
</P><P>

関数 <CODE>eb_is_text_stopped()</CODE> は、最後に読み込んだテキストデータが
末尾に達したかどうかを判定します。
</P><P>

<VAR>book</VAR> が選択中の副本で、最後に <CODE>eb_read_text()</CODE> または
<CODE>eb_read_heading()</CODE> でテキストデータを読み込んだ際に、区切りコード
を検出したか、テキストデータの末尾に達して読み込みを終えていれれば、この
関数は 1 を返します。
それ以外のときは、0 を返します。
</P><P>

<VAR>book</VAR> が副本を選択していない場合や、選択中の副本にテキストデータが
存在しない場合も 0 が返ります。
</P><P>

<CODE>eb_read_text()</CODE> または <CODE>eb_read_heading()</CODE> でテキストデータ
を読み込んでいない場合も、同様に 0 が返ります。
テキストデータを読み込んだ後であっても、テキストデータの読み込みに関する
状態記録をリセットする関数 (eb_read_text() の項を参照) を呼んでしまうと、
読み込んでいないと見なされますので、注意して下さい。
</P><P>

通常はこの関数を使わなくても、<CODE>eb_read_text()</CODE> や
<CODE>eb_read_heading()</CODE> が 0 を返したら、テキストデータの末尾に達した
とみなして差し支えないでしょう。
ただしその際は、引数 <CODE>text_max_length</CODE> の値を十分大きく取って下さい。
</P><P>

</DL>
</P><P>

<A NAME="IDX380"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_write_text_byte1</B> <I>(EB_Book *<VAR>book</VAR>, int <VAR>byte1</VAR>)</I>
<DD><A NAME="IDX381"></A>
<DT><U>Function:</U> EB_Error_Code <B>eb_write_text_byte2</B> <I>(EB_Book *<VAR>book</VAR>, int <VAR>byte1</VAR>, int <VAR>byte2</VAR>)</I>
<DD><A NAME="IDX382"></A>
<DT><U>Function:</U> EB_Error_Code <B>eb_write_text_string</B> <I>(EB_Book *<VAR>book</VAR>, const char *<VAR>string</VAR>)</I>
<DD><A NAME="IDX383"></A>
<DT><U>Function:</U> EB_Error_Code <B>eb_write_text</B> <I>(EB_Book *<VAR>book</VAR>, const char *<VAR>stream</VAR>, size_t <VAR>stream_length</VAR>)</I>
<DD><A NAME="IDX384"></A>
<A NAME="IDX385"></A>
<A NAME="IDX386"></A>
<A NAME="IDX387"></A>
</P><P>

これらの関数は、いずれもフック関数の中から、テキストデータを書き込む
ために用います。
書き込むデータの種類によって、使い分けて下さい。
</P><P>

<CODE>eb_write_text_byte1()</CODE> は、<VAR>byte1</VAR> で指定した 1 バイトの値を
書き込みます。
<CODE>eb_write_text_byte2()</CODE> は、<VAR>byte1</VAR>, <VAR>byte2</VAR> で指定した
2 バイトを書き込みます。
<CODE>eb_write_text_string()</CODE> は、<VAR>string</VAR> で指定した文字列を
書き込みます。
<CODE>eb_write_text()</CODE> は、<VAR>stream</VAR> から始まる長さ <VAR>stream_length</VAR>
バイトのバイト列を書き込みます。
</P><P>

どの関数も、成功すると <CODE>EB_SUCCESS</CODE> を返し、失敗すると原因を示す
エラーコードを返します。
</P><P>

最終的に、書き込んだテキストデータは、フック関数の呼び出し元である
<CODE>eb_read_text()</CODE>, <CODE>eb_read_heading()</CODE> から
アプリケーションプログラムに渡されます。
</P><P>

フック関数として呼び出されていないときに、これらの関数を呼び出した場合
の動作は未定義です。
</DL>
</P><P>

<A NAME="IDX388"></A>
<DL>
<DT><U>Function:</U> const char * <B>eb_current_candidate</B> <I>(EB_Book *<VAR>book</VAR>)</I>
<DD><A NAME="IDX389"></A>
</P><P>

関数 <CODE>eb_current_candidate()</CODE> は、アクセス中のテキストデータの
現在位置に書かれている、複合検索の候補となる語を返します。
</P><P>

返す文字列の長さは、最長で <CODE>EB_MAX_WORD_LENGTH</CODE> バイトになります。
ただし、この長さにナル文字は含みません。
</P><P>

この関数は非常に特殊で、複合検索の候補となる語の終了を意味する
エスケープシーケンスへのフックである <CODE>EB_HOOK_END_CANDIDATE_LEAF</CODE>
および <CODE>EB_HOOK_END_CANDIDATE_GROUP</CODE> に対するフック関数の中でのみ
呼び出すことができます。
それ以外の場所で呼び出したときの動作は、未定義です。
</P><P>

この関数の呼び出し方ですが、フック関数に渡ってきた <CODE>EB_Book</CODE> 
オブジェクト (へのポインタ) を、そのままこの関数に引数として渡して
やります。
</P><P>

<VAR>book</VAR> の文字コード
(「<A HREF="eb-ja_5.html#SEC21">[CD-ROM 書籍と <CODE>EB_Book</CODE> オブジェクト] データ型の詳細</A>」節を参照)
が <CODE>EB_CHARCODE_ISO8859_1</CODE> なら、関数の返す文字列は ISO 8859-1 
になり、それ以外の文字コードの場合は日本語 EUC になります。
関数の返す文字列は、他のフックによる加工処理の影響を受けません。
文字コードの変換を行う以外は、内部データをそのまま返します。
</P><P>

なお、この関数が返した文字列を参照できるのは、フック関数から戻るまでの
間だけですので、注意して下さい。
</DL>
</P><P>

<A NAME="IDX390"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_forward_text</B> <I>(EB_Book *<VAR>book</VAR>, EB_Appendix *<VAR>appendix</VAR>)</I>
<DD><A NAME="IDX391"></A>
<DT><U>Function:</U> EB_Error_Code <B>eb_backward_text</B> <I>(EB_Book *<VAR>book</VAR>, EB_Appendix *<VAR>appendix</VAR>)</I>
<DD><A NAME="IDX392"></A>
<A NAME="IDX393"></A>
</P><P>

関数 <CODE>eb_forward_text()</CODE> と <CODE>eb_backward_text()</CODE> は、
<VAR>book</VAR> が選択している副本の本文のアクセス位置を前後に移動させ、
本文の区切りコードを単位とした頭出しを行います。
ちょうど、音楽 CD の曲の頭出しと同じです。
</P><P>

<CODE>eb_forward_text()</CODE> は本文の末尾方向に向かってアクセス位置を
進め、<CODE>eb_backward_text()</CODE> は先頭方向に向かってアクセス位置を
戻します。
</P><P>

<CODE>eb_forward_text()</CODE> の呼び出しでは、アクセス位置は必ず次の語の
説明の開始位置まで移動します。
それに対して <CODE>eb_backward_text()</CODE> の呼び出しでは、移動先が状態
によって異なります。
もし、現在のアクセス位置がその単語の説明の先頭にあるときは、
<CODE>eb_backward_text()</CODE> の呼び出しによって、一つ前の単語の説明の
先頭にアクセス位置が移動します。
アクセス位置が単語の説明の途中や末尾にあるときは、その単語の説明の
先頭に移動します。
</P><P>

この関数は、成功すると <CODE>EB_SUCCESS</CODE> を返し、失敗すると原因を示す
エラーコードを返します。
</P><P>

あらかじめ、<VAR>book</VAR> 内のいずれかの副本が選択されていなくてはなりません。
<VAR>book</VAR> が副本を選択していなければ、<CODE>EB_ERR_NO_CUR_SUB</CODE> を返します。
</P><P>

加えて、これらの関数を呼び出すには、あらかじめ <CODE>eb_seek_text()</CODE> か
<CODE>eb_read_text()</CODE> を呼び出しが成功していないといけません。
(<CODE>eb_read_text()</CODE> の呼び出しを成功させるには、さらに前もって 
<CODE>eb_seek_text()</CODE> の呼び出しを成功させることが条件となります。)
</P><P>

<CODE>eb_read_text()</CODE> ではなく、<CODE>eb_read_heading()</CODE> や
<CODE>eb_read_rawtext()</CODE> の呼び出しに成功した後でこの関数を呼び出すと、
<CODE>EB_ERR_DIFF_CONTENT</CODE> を返します。
また、前もって <CODE>eb_seek_text()</CODE> でシークせずにこの関数を呼び出すと、
<CODE>EB_ERR_NO_PREV_SEEK</CODE> を返します。
</P><P>

本文データの末尾や先頭に達してしまって、その方向にもう本文がないときは、
<CODE>EB_ERR_END_OF_CONTENT</CODE> を返します。
</P><P>

<VAR>appendix</VAR> が <CODE>NULL</CODE> ではなく、区切りコードの情報を持った副本
を選択中であれば、本文の区切りコードとしてその値を使用します。
それ以外の場合は、<CODE>eb_read_text()</CODE> と同じ方法で区切りコードの
自動判別を試みます。
</P><P>

アクセス位置上にあるのがメニューや著作権表示のように、本文以外の
テキストデータであっても、構いません。
ただし、本文以外のテキストデータの内部には、頭出し位置が一箇所しか
ありませんので、この関数が役に立つ状況はほとんどありません。
</P><P>

(メニューでは、個々の階層のメニューデータが、それぞれ独立した
テキストデータになっているため、頭出しを行っても前後のメニューデータへは
移動できません。
複合検索の候補一覧も同様です。)
</DL>
</P><P>

<A NAME="Local Character"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_9.html#SEC44"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Motoyuki Kasahara</I> on <I>December, 28  2003</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
