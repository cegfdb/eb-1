<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on December, 28  2003 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>EB Library: Binary Data</TITLE>

<META NAME="description" CONTENT="EB Library: Binary Data">
<META NAME="keywords" CONTENT="EB Library: Binary Data">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="EN" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC71"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC70"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC72"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_10.html#SEC60"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_12.html#SEC77"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 11. バイナリデータ </H1>
<!--docid::SEC71::-->
<P>

<EM>バイナリデータ (binary data)</EM> とは、テキストデータ
(「<A HREF="eb-ja_9.html#SEC44">テキストデータ</A>」節を参照) から参照される、図版や動画、音声
といったマルチメディアデータのことを指します。
</P><P>

今のところ EB ライブラリでは、全種類のバイナリデータを取り扱うことが
できるわけではありません。
電子ブックで扱えるのは、2 階調のモノクロ図版と、カラー図版 (JPEG) だけ
です。
EPWING では、モノクロ図版、カラー図版 (BMP および JPEG) に加えて、
WAVE (PCM) 音声、MPEG 動画を扱うことができます。
</P><P>

ただし、EB ライブラリが提供しているのは、こうしたバイナリデータを
CD-ROM 書籍から取得する機能だけです。
表示したり再生したりする機能は用意していませんので、注意して下さい。
</P><P>

アプリケーションは、英和辞書や国語辞書といった辞書だけを対象にするなら、
バイナリデータの表示や再生には対応しなくても支障はありません。
しかし一方では、図鑑や数式の表現にモノクロ図版を使っている数学辞典の
ように、対応しないと不便なものもあります。
バイナリデータの表示や再生の機能を実装するかどうかは、アプリケーション
の対象辞書をどの範囲までにするのかによって決めると良いでしょう。
</P><P>

以下、この章では種類別にバイナリデータの扱い方について説明します。
</P><P>

バイナリデータの種類毎にデータの取り出し方は微妙に異なりますが (これは
データの収録方法が微妙に異なっているからに他なりません)、おおよそ手順
は、次のようなものになります。
</P><P>

<OL>
<LI>テキストデータのフックを用いて、バイナリデータの参照情報を
取得する
<P>

<LI><CODE>eb_binary_set_...()</CODE> 関数を呼び出して、指定した位置の
バイナリデータをこれから読み込む旨を EB ライブラリに伝える。
<P>

<LI><CODE>eb_read_binary()</CODE> で実際にデータを読み込む。
</OL>
<P>

テキストデータと同様に、バイナリデータも副本に属するデータ
ですので、副本を選択していないと取得することはできません。
バイナリデータの読み込みには、テキストデータとは別の
ファイルディスクリプタが割り当てられます。
したがって、双方を交互に読み込んでも、動作には影響はありません。
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_11.html#SEC72">11.1 モノクロ図版</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_11.html#SEC73">11.2 カラー図版</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_11.html#SEC74">11.3 WAVE (PCM) 音声</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">WAVE 音声</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_11.html#SEC75">11.4 MPEG1 動画</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="eb-ja_11.html#SEC76">11.5 関数の詳細</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Monochrome Image"></A>
<HR SIZE="6">
<A NAME="SEC72"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC73"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_12.html#SEC77"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.1 モノクロ図版 </H2>
<!--docid::SEC72::-->
<P>

2 階調のモノクロ図版は、電子ブック、EPWING 双方に存在し、EB ライブラリ
ではどちらも扱うことができます。
(電子ブックに存在する 16 階調のモノクロ図版は、今のところ EB ライブラリ
では対応していません。)
</P><P>

モノクロ図版データの内部形式は外字と同じですが、EB ライブラリでは、
1 ピクセルに 1bit を割り当てた BMP 形式に変換してアプリケーションに
渡すようにしています。
したがって、アプリケーションからは、あたかも BMP の図版データが収録
されているようにみえます。
</P><P>

モノクロ図版の取り出し方ですが、これにはまずモノクロ図版の参照開始と終了
を表すエスケープシーケンスへのフック <CODE>EB_HOOK_BEGIN_MONO_GRAPHIC</CODE>
と <CODE>EB_HOOK_END_MONO_GRAPHIC</CODE> を使います。
</P><P>

フック <CODE>EB_HOOK_BEGIN_MONO_GRAPHIC</CODE> がフック関数に渡す引数
(<CODE>argv</CODE>) は 4 つあり、このうちの <CODE>argv[2]</CODE> と <CODE>argv[3]</CODE> 
が図版の幅と高さ (ピクセル数) を意味します。
</P><P>

また、フック <CODE>EB_HOOK_END_MONO_GRAPHIC</CODE> がフック関数に渡す引数
は 3 つで、<CODE>argv[1]</CODE> と <CODE>argv[2]</CODE> が、図版データのページ番号
とオフセットになります。
</P><P>

モノクロ図版を取得するには、上記のフックから得た図版のページ番号と
オフセット、および幅と高さを記憶しておきます。
</P><P>

次に、<CODE>eb_set_binary_mono_graphic()</CODE> を呼び出して、これから
モノクロ図版のデータを取得することを EB ライブラリに伝えます。
<CODE>eb_set_binary_mono_graphic()</CODE> への引数には、
<CODE>EB_Book</CODE> オブジェクトと、先ほど得た図版へのページ番号、オフセット、
幅、高さを渡します。
<CODE>EB_Book</CODE> オブジェクトは、これから取り出そうとしている図版を収録
している副本をあらかじめ選択しておく必要があります。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>/* <CODE>eb_set_binary_mono_graphic()</CODE> の関数プロトタイプ */
EB_Error_Code
eb_set_binary_mono_graphic(EB_Book *book, EB_Position *position,
    int width, int height);
</pre></td></tr></table></P><P>

電子ブックでは、フック関数に渡される幅と高さの値は 0 になっていますが、
そのまま <CODE>eb_set_binary_mono_graphic()</CODE> に渡します。
(EPWING では 0 を渡してはいけません。)
</P><P>

以上で図版データの取得準備ができたので、データを読み込みます。
これには、<CODE>eb_read_binary()</CODE> を使います。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#define MAX_LENGTH 1000
char bitmap[MAX_LENGTH];
ssize_t bitmap_length;

if (eb_read_binary(&#38;book, MAX_LENGTH, bitmap, &#38;bitmap_length)
    != EB_SUCCESS) {
    fprintf(stderr, "an error occurs.\n");
    return;
}
</pre></td></tr></table></P><P>

成功すると、読み込んだ図版データが <CODE>bitmap</CODE> に書き込まれ、何バイト
書き込んだのかが <CODE>bitmap_length</CODE> に書き込まれます。
書き込まれるバイト数は、最大で <CODE>MAX_LENGTH</CODE> バイトです。
</P><P>

必ずしも一回の <CODE>eb_read_binary()</CODE> の呼び出しで図版データを終端まで
読み込む必要はなく、関数を繰り返し呼び出せば、前回の続きを読み込むこと
ができます。
<CODE>eb_read_binary()</CODE> は、図版データの終端まで来るとそれ以上データ
は読み込みませんので、<CODE>eb_read_binary()</CODE> が 0 を返した時点で
図版データが終端したことを認識できます。
</P><P>

<A NAME="Color Image"></A>
<HR SIZE="6">
<A NAME="SEC73"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC72"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC74"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_12.html#SEC77"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.2 カラー図版 </H2>
<!--docid::SEC73::-->
<P>

カラー図版は、電子ブックでは JPEG 形式、EPWING では JPEG と BMP (DIB)
形式のものが使用されています。
EB ライブラリはこれらをすべて扱うことができますが、電子ブックへの対応
は限定的なものになっています。(詳しくは後述します。)
</P><P>

カラー図版のデータを取り出すには、まず <CODE>eb_set_binary_color_graphic()</CODE>
を呼び出して、これからアプリケーションがカラー図版のデータを取得しよう
としていることを EB ライブラリに伝えます。
<CODE>eb_set_binary_color_graphic()</CODE> への引数には、
<CODE>EB_Book</CODE> オブジェクトに加えて、カラー図版のページ番号とオフセット
を渡します。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>/* <CODE>eb_set_binary_color_graphic()</CODE> の関数プロトタイプ */
EB_Error_Code
eb_set_binary_color_graphic(EB_Book *book, EB_Position *position);
</pre></td></tr></table></P><P>

<CODE>EB_Book</CODE> オブジェクトは、これから取り出そうとしている図版を収録
している副本をあらかじめ選択しておきます。
カラー図版のページ番号とオフセットの情報は、カラー図版の参照開始と終了
を表すエスケープシーケンスへのフックから得ます。
フックは、インライン表示用と非インライン用の 2 種類があり、さらに
それぞれ開始フックが JPEG 用と BMP 用に分かれています。
</P><P>

<DL COMPACT>
<DT><CODE>EB_HOOK_BEGIN_COLOR_BMP</CODE>
<DD><DT><CODE>EB_HOOK_BEGIN_COLOR_JPEG</CODE>
<DD>非インライン用 BMP, JPEG の開始フック
<P>

<DT><CODE>EB_HOOK_END_COLOR_GRAPHIC</CODE>
<DD>非インライン用カラー図版 (BMP, JPEG 共通) の終了フック
<P>

<DT><CODE>EB_HOOK_BEGIN_IN_COLOR_BMP</CODE>
<DD><DT><CODE>EB_HOOK_BEGIN_IN_COLOR_JPEG</CODE>
<DD>インライン用 BMP, JPEG の開始フック
<P>

<DT><CODE>EB_HOOK_END_IN_COLOR_GRAPHIC</CODE>
<DD>非インライン用カラー図版 (BMP, JPEG 共通) の終了フック
</DL>
<P>

非インライン用の終了フック <CODE>EB_HOOK_END_GRAPHIC</CODE> では、フック関数
に渡す引数の <CODE>argv[1]</CODE> と <CODE>argv[2]</CODE> が、図版データのページ
番号とオフセットになりますので、これを <CODE>eb_set_binary_color_graphic()</CODE>
に渡してやります。 
同様に、インライン用の終了フック <CODE>EB_HOOK_END_IN_GRAPHIC</CODE> では、
<CODE>argv[2]</CODE> と <CODE>argv[3]</CODE> がページ番号とオフセットですので、
これを渡します。
</P><P>

後は、実際にカラー図版のデータを取り出します。
これには、モノクロ図版と同様に <CODE>eb_read_binary()</CODE> を用います。
使い方はまったく一緒ですので、詳しくは
「<A HREF="eb-ja_11.html#SEC72">モノクロ図版</A>」節を参照 を参照してください。
</P><P>

ただし、電子ブックのカラー図版については、データの終了位置が来ても
EB ライブラリは読み込みを止めないという制限事項があります。
これは、データの大きさに関する情報が記されていないためで、データの
終端位置は、アプリケーションが JPEG のデータをデコードして割り出すしか
ありません。
</P><P>

<A NAME="WAVE Sound"></A>
<HR SIZE="6">
<A NAME="SEC74"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC73"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC75"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_12.html#SEC77"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.3 WAVE (PCM) 音声 </H2>
<!--docid::SEC74::-->
<P>

WAVE (PCM) 形式の音声データは EPWING にだけ存在します。
(代わりに電子ブックには CD-DA 形式の音声データがありますが、EB ライブラリ
では対応していません。)
</P><P>

WAVE 形式の音声データを取り出すには、まず WAVE 音声の参照開始と終了を
表すエスケープシーケンスへのフック <CODE>EB_HOOK_BEGIN_WAVE</CODE> と
<CODE>EB_HOOK_END_WAVE</CODE> を使います。
</P><P>

フック <CODE>EB_HOOK_BEGIN_WAVE</CODE> がフック関数に渡す引数のうち、
<CODE>argv[2]</CODE> と <CODE>argv[3]</CODE> が音声データの開始位置のページ番号と
オフセット、<CODE>argv[4]</CODE> と <CODE>argv[5]</CODE> が終了位置のページ番号と
オフセットとなります。
</P><P>

この開始位置と終了位置を関数 <CODE>eb_set_binary_wave()</CODE> に渡して、その
位置にある音声データをこれから取り出すことを EB ライブラリに伝えます。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>/* <CODE>eb_set_binary_wave()</CODE> の関数プロトタイプ */
EB_Error_Code
eb_set_binary_wave(EB_Book *book, EB_Position *start_position,
EB_Position *end_position);
</pre></td></tr></table></P><P>

そして後は、実際に音声データを取り出します。
これには、他のバイナリデータと同様に <CODE>eb_read_binary()</CODE> を用います。
<CODE>eb_read_binary()</CODE> の使い方は、
「<A HREF="eb-ja_11.html#SEC72">モノクロ図版</A>」節を参照 を参照してください。
</P><P>

<A NAME="MPEG Movie"></A>
<HR SIZE="6">
<A NAME="SEC75"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC74"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC76"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_12.html#SEC77"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.4 MPEG1 動画 </H2>
<!--docid::SEC75::-->
<P>

MPEG1 形式の動画データは EPWING にだけ存在します。
動画データは EPWING の CD-ROM の movie というディレクトリの下に、
動画毎に一個のファイルにした形で収められています。
</P><P>

MPEG データの参照開始と終了を表すエスケープシーケンスへのフック
<CODE>EB_HOOK_BEGIN_MPEG</CODE> と <CODE>EB_HOOK_END_MPEG</CODE> を使用すると、
参照先の MPEG のファイル名を取得できます。
具体的には、フック <CODE>EB_HOOK_BEGIN_MPEG</CODE> がフック関数に渡す引数の
うち、<CODE>argv[2]</CODE> 〜 <CODE>argv[5]</CODE> が合わせて一つのファイル名を
表すようになっています。
</P><P>

MPEG 動画のデータを得るには、このファイル名を <CODE>eb_set_binary_mpeg()</CODE>
に渡して、そのファイルの動画データをこれから取り出す旨を EB ライブラリ
に伝えます。
ファイル名は、次のようにして <CODE>argv + 2</CODE> (<CODE>&#38;argv[2]</CODE> でも同じ)
を渡します。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>if (eb_set_binary_mpeg(&#38;book, argv + 2) != EB_SUCCESS) {
    fprintf(stderr, "an error occurs.\n");
    return;
}
</pre></td></tr></table></P><P>

後は、実際に動画データを取り出します。
これには、やはり他のバイナリデータと同様に <CODE>eb_read_binary()</CODE> を
用います。
<CODE>eb_read_binary()</CODE> の使い方については、
「<A HREF="eb-ja_11.html#SEC72">モノクロ図版</A>」節を参照 を参照してください。
</P><P>

<A NAME="Binary Data Functions"></A>
<HR SIZE="6">
<A NAME="SEC76"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC75"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_12.html#SEC77"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_12.html#SEC77"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.5 関数の詳細 </H2>
<!--docid::SEC76::-->
<P>

この節で説明している関数を使うには、次のようにヘッダファイルを読み込んで
下さい。
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>#include &#60;eb/binary.h&#62;
</pre></td></tr></table></P><P>

<A NAME="IDX593"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_set_binary_mono_graphic</B> <I>(EB_Book *<VAR>book</VAR>, const EB_Position *<VAR>position</VAR>, int <VAR>width</VAR>, <VAR>height</VAR>)</I>
<DD><A NAME="IDX594"></A>
</P><P>

関数 <CODE>eb_set_binary_mono_graphic()</CODE> は、モノクロ図版のデータを
これから取得しようとしていることを EB ライブラリに伝えます。
引数 <VAR>position</VAR> は図版の位置、<VAR>width</VAR>, <VAR>height</VAR> には図版の
幅と高さを渡します。
これらの情報は、図版の参照元であるテキストデータに記載されており、通常は
フック関数を通じて得るようにします。
ただし、電子ブックでは幅と高さの値の情報がテキストデータに記されていない
ため、0 を渡すことになります。
</P><P>

成功すると、関数は <CODE>EB_SUCCESS</CODE> を返します。
失敗すると、原因に応じたエラーコードを返します。
</P><P>

あらかじめ、図版を取り出そうとしている副本を選択しておかなければ
なりません。
<VAR>book</VAR> が副本を選択していなければ、<CODE>EB_ERR_NO_CUR_SUB</CODE> を
返します。
図版の位置、幅、高さの値が明らかにおかしいと EB ライブラリが判断した
ときは、<CODE>EB_ERR_NO_SUCH_BINARY</CODE> を返します。
</P><P>

この関数は、実際に図版データを読み込むことはしません。
読み込みには、<CODE>eb_read_binary()</CODE> を用います。
モノクロ図版のデータは、1 ピクセルに 1bit を割り当てた BMP 形式になって
います。
</DL>
</P><P>

<A NAME="IDX595"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_set_binary_color_graphic</B> <I>(EB_Book *<VAR>book</VAR>, const EB_Position *<VAR>position</VAR>)</I>
<DD><A NAME="IDX596"></A>
</P><P>

関数 <CODE>eb_set_binary_color_graphic()</CODE> は、EPWING のカラー図版のデータを
これから取得しようとしていることを EB ライブラリに伝えます。
引数 <VAR>position</VAR> は図版の位置を渡します。
位置の情報は、図版の参照元であるテキストデータに記載されており、通常は
フック関数を通じて得るようにします。
</P><P>

成功すると、関数は <CODE>EB_SUCCESS</CODE> を返します。
</P><P>

あらかじめ、図版を取り出そうとしている副本を選択しておかなければ
なりません。
<VAR>book</VAR> が副本を選択していなければ、<CODE>EB_ERR_NO_CUR_SUB</CODE> を
返します。
図版の位置が明らかにおかしいと EB ライブラリが判断したときは、
<CODE>EB_ERR_NO_SUCH_BINARY</CODE> を返します。
</P><P>

この関数は、実際に図版データを読み込むことはしません。
読み込みには、<CODE>eb_read_binary()</CODE> を用います。
カラー図版データは、JPEG か BMP (DIB) のいずかの形式になっています。
</DL>
</P><P>

<A NAME="IDX597"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_set_binary_wave</B> <I>(EB_Book *<VAR>book</VAR>, const EB_Position *<VAR>start_position</VAR>, EB_Position *<VAR>end_position</VAR>)</I>
<DD><A NAME="IDX598"></A>
</P><P>

関数 <CODE>eb_set_binary_wave()</CODE> は、WAVE (PCM) 形式の音声のデータを
これから取得しようとしていることを EB ライブラリに伝えます。
引数 <VAR>start_position</VAR> と <VAR>end_position</VAR> には音声データの開始位置
を渡します。
位置の情報は、音声データの参照元であるテキストデータに記載されており、
通常はフック関数を通じて得るようにします。
</P><P>

成功すると、関数は <CODE>EB_SUCCESS</CODE> を返します。
失敗すると、原因に応じたエラーコードを返します。
</P><P>

あらかじめ、音声データを取り出そうとしている副本を選択しておかなければ
なりません。
<VAR>book</VAR> が副本を選択していなければ、<CODE>EB_ERR_NO_CUR_SUB</CODE> を
返します。
音声データの位置が明らかにおかしいと EB ライブラリが判断したときは、
<CODE>EB_ERR_NO_SUCH_BINARY</CODE> を返します。
</P><P>

この関数は、実際に音声データを読み込むことはしません。
読み込みには、<CODE>eb_read_binary()</CODE> を用います。
</DL>
</P><P>

<A NAME="IDX599"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_set_binary_mpeg</B> <I>(EB_Book *<VAR>book</VAR>, const unsigned int *<VAR>argv</VAR>)</I>
<DD><A NAME="IDX600"></A>
</P><P>

関数 <CODE>eb_set_binary_mpeg()</CODE> は、MPEG1 形式の動画のデータをこれから
取得しようとしていることを EB ライブラリに伝えます。
引数 <VAR>argv</VAR> には動画データのファイル名を渡します。
ただし、このファイル名は文字列ではなく、フック関数
<CODE>EB_HOOK_BEGIN_MPEG</CODE> に渡された引数 <CODE>argv[2]</CODE> 〜 <CODE>argv[5]</CODE>
の部分を渡します。
つまり、フック関数の引数 <CODE>argv + 2</CODE> を、<CODE>eb_set_binary_mpeg()</CODE> 
への引数 <VAR>argv</VAR> として渡します。
</P><P>

成功すると、関数は <CODE>EB_SUCCESS</CODE> を返します。
失敗すると、原因に応じたエラーコードを返します。
</P><P>

あらかじめ、動画データを取り出そうとしている副本を選択しておかなければ
なりません。
<VAR>book</VAR> が副本を選択していなければ、<CODE>EB_ERR_NO_CUR_SUB</CODE> を
返します。
存在しない動画ファイル名を EB ライブラリが判断したときは、
<CODE>EB_ERR_NO_SUCH_BINARY</CODE> を返します。
</P><P>

成功すると、関数は <CODE>EB_SUCCESS</CODE> を返します。
</P><P>

この関数は、実際に動画データを読み込むことはしません。
読み込みには、<CODE>eb_read_binary()</CODE> を用います。
</DL>
</P><P>

<A NAME="IDX601"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_read_binary</B> <I>(EB_Book *<VAR>book</VAR>, size_t <VAR>binary_max_length</VAR>, char *<VAR>binary</VAR>, ssize_t *<VAR>binary_length</VAR>)</I>
<DD><A NAME="IDX602"></A>
</P><P>

関数 <CODE>eb_read_binary()</CODE> は、バイナリデータを読み込みます。
読み込もうとしているバイナリデータは、事前に
</P><P>

<UL>
<LI><CODE>eb_set_binary_mono_graphic()</CODE>
<LI><CODE>eb_set_binary_color_graphic()</CODE>
<LI><CODE>eb_set_binary_wave()</CODE>
<LI><CODE>eb_set_binary_mpeg()</CODE>
</UL>
<P>

のいずれかの関数で、EB ライブラリに通知しておく必要があります。
</P><P>

読み込んだデータは引数 <VAR>binary</VAR> の指す先の領域に書き込まれます。
また、このとき書き込まれたバイト数は、<VAR>binary_length</VAR> の指す先の
領域にセットされます。
ただし、書き込まれるバイト数は、最長でも引数 <VAR>binary_max_length</VAR> に
指定した値までとなります。
</P><P>

この関数は、特に読み込んだデータの終端にナル文字を付加するような事は
しません。
読み込まれるデータもバイナリ形式なので、途中にナル文字が出現する事も
あります。
</P><P>

この関数を一回呼び出しだだけで、バイナリデータ全体を一気に取得する
必要はありません。
繰り返し呼び出せば、前回の続きからデータが読み込まれます。
</P><P>

ただし、以下に挙げた関数を呼び出すと、バイナリデータの読み込みに関する
状態記録がリセットされますので、それ以上の読み込みはできなくなります。
</P><P>

<UL>
<LI><CODE>eb_set_subbook()</CODE>
<LI><CODE>eb_unset_subbook()</CODE>
<LI><CODE>eb_load_all_subbooks()</CODE>
<LI><CODE>eb_bind()</CODE>
<LI><CODE>eb_finalize_book()</CODE>
<LI><CODE>eb_set_binary_mono_graphic()</CODE>
<LI><CODE>eb_set_binary_color_graphic()</CODE>
<LI><CODE>eb_set_binary_wave()</CODE>
<LI><CODE>eb_set_binary_mpeg()</CODE>
</UL>
<P>

<CODE>eb_read_binary()</CODE> を繰り返し呼んだ場合、バイナリデータはその都度
<VAR>binary</VAR> の先頭から書き込まれ、*<VAR>binary_length</VAR> の値も、その回
の <CODE>eb_read_binary()</CODE> の呼び出しで書き込まれたバイト数になります。
</P><P>

データの終端に来ると、それ以上この関数を呼んでも関数は <VAR>binary</VAR> には
何も書き込まず、*<VAR>binary_length</VAR> に 0 を書き込み、<CODE>EB_SUCCESS</CODE>
を返します。
</P><P>

成功すると、この関数は <CODE>EB_SUCCESS</CODE> を返します。
失敗すると、<VAR>binary_length</VAR> が指す領域に -1 を書き込み、原因を示す
エラーコードを返します。
この場合、バイナリデータの読み込み状態の記録がリセットされますので、
データの続きを読み込むことはできなくなります。
</P><P>

あらかじめ、<VAR>book</VAR> はいずれかの副本を選択していなくてはなりません。
選択していない場合は、<CODE>EB_ERR_NO_CUR_SUB</CODE> を返します。
また、冒頭に挙げた関数の呼び出しが成功していない状態でこの関数を呼ぶと、
<CODE>EB_ERR_NO_CUR_BINARY</CODE> を返します。
</DL>
</P><P>

<A NAME="IDX603"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_compose_movie_file_name</B> <I>(const unsigned int *<VAR>argv</VAR>, char *<VAR>composed_file_name</VAR>)</I>
<DD><A NAME="IDX604"></A>
</P><P>

関数 <CODE>eb_compose_movie_file_name()</CODE> は、動画データのファイル名を
通常の文字列に変換します。
</P><P>

EB ライブラリでは、動画データのファイル名はフック関数
<CODE>EB_HOOK_BEGIN_MPEG</CODE> に渡された 4 つの int 型引数
(<CODE>argv[2]</CODE> 〜 <CODE>argv[5]</CODE>) によって表現されます。
</P><P>

動画データを読み込む際は、これをそのまま <CODE>eb_set_binary_mpeg()</CODE> に
渡せば良いのですが、ファイル名を通常の文字列で得たい場合は、この関数を
用います。
たとえば、個々の動画に一意の ID のようなものを振りたい場合は、ファイル
名を ID として使うと良いかも知れません。
</P><P>

フック関数の引数 <CODE>argv + 2</CODE> をこの関数への引数 <VAR>argv</VAR> として
渡すと、<VAR>composed_file_name</VAR> が指す先の領域に、文字列形式に変換された
ファイル名が格納されます。
ファイル名は最長で <CODE>EB_MAX_DIRECTORY_NAME_LENGTH</CODE> (= 8) バイトに
なります。
この長さには終端のナル文字の分を含んでいませんので、格納領域にははもう
1 バイト余裕が要ります。
</P><P>

なお、格納されたファイル名は、実際に存在するファイル名とは若干異なっている
可能性があります。
たとえば、英字の大文字と小文字、接尾子の有無などの違いがこれに当たります。
</P><P>

成功すると、関数は <CODE>EB_SUCCESS</CODE> を返します。
</DL>
</P><P>

<A NAME="IDX605"></A>
<DL>
<DT><U>Function:</U> EB_Error_Code <B>eb_decompose_movie_file_name</B> <I>(unsigned int *<VAR>argv</VAR>, const char *<VAR>composed_file_name</VAR>)</I>
<DD><A NAME="IDX606"></A>
</P><P>

関数 <CODE>eb_compose_movie_file_name()</CODE> は、
<CODE>eb_compose_movie_file_name()</CODE> とちょうど逆の働きをします。
つまり、通常の文字列に変換された動画データのファイル名
<VAR>composed_file_name</VAR> を、4 つの int 型引数 <VAR>argv</VAR> に戻します。
したがって、<VAR>argv</VAR> の指す領域は、少なくとも int 型の値を 4 つ格納
できる大きさが必要です。
</P><P>

成功すると、関数は <CODE>EB_SUCCESS</CODE> を返します。
</DL>
</P><P>

<A NAME="Appendix Data"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_11.html#SEC71"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_12.html#SEC77"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="eb-ja_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Motoyuki Kasahara</I> on <I>December, 28  2003</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
